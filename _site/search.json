[
  {
    "objectID": "search.html",
    "href": "search.html",
    "title": "Search",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nBathymetric data\n\n\n\n\n\n\nBoundary\n\n\n\n\n\n\nCombining Datasets\n\n\n\n\n\n\nContributing\n\n\n\n\n\n\nDFS2 - Export to NetCDF\n\n\n\n\n\n\nDataArray - Arithmetic\n\n\n\n\n\n\nDataArray - Dfs123 plotting\n\n\n\n\n\n\nDataArray - Dfsu plotting\n\n\n\n\n\n\nDataArray - Masking\n\n\n\n\n\n\nDataset - Add new item\n\n\n\n\n\n\nDataset - Plotting\n\n\n\n\n\n\nDfs0 - CMEMS in-situ data\n\n\n\n\n\n\nDfs0 - Relative time axis\n\n\n\n\n\n\nDfs1 - Read\n\n\n\n\n\n\nDfs2 - Slicing\n\n\n\n\n\n\nDfs2 - Various types\n\n\n\n\n\n\nDfs3 - Basic\n\n\n\n\n\n\nDfsu - 2D interpolation\n\n\n\n\n\n\nDfsu - 3D sigma-z\n\n\n\n\n\n\nDfsu - Connectivity\n\n\n\n\n\n\nDfsu - Distance to land\n\n\n\n\n\n\nDfsu - Export to netcdf\n\n\n\n\n\n\nDfsu - Export to shapefile\n\n\n\n\n\n\nDfsu - Extract Track\n\n\n\n\n\n\nDfsu - Read\n\n\n\n\n\n\nDfsu - Speed and direction\n\n\n\n\n\n\nDfsu - Vertical Profile\n\n\n\n\n\n\nDfsu - spectral data\n\n\n\n\n\n\nDfsu and Mesh - Plotting\n\n\n\n\n\n\nGeneric dfs processing\n\n\n\n\n\n\nGlobal Forecasting System - Meteorological forecast\n\n\n\n\n\n\nMesh\n\n\n\n\n\n\nMore Dfsu spectral files\n\n\n\n\n\n\nPFS\n\n\n\n\n\n\nTime interpolation\n\n\n\n\n\n\nWrite a dfs0\n\n\n\n\n\n\nmikeio-examples\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "This site contains a a collection of notebooks with various data processing tasks using MIKE IO.\nMade with Quarto https://quarto.org/docs/websites."
  },
  {
    "objectID": "contributing.html",
    "href": "contributing.html",
    "title": "Contributing",
    "section": "",
    "text": "How to contribute an example to mikeio-examples…"
  },
  {
    "objectID": "notebooks/Dfs0 - Timeseries.html",
    "href": "notebooks/Dfs0 - Timeseries.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nimport mikeio\nfrom mikeio import ItemInfo, EUMType, EUMUnit"
  },
  {
    "objectID": "notebooks/Dfs0 - Timeseries.html#from-comma-separated-file",
    "href": "notebooks/Dfs0 - Timeseries.html#from-comma-separated-file",
    "title": "mikeio-examples",
    "section": "From comma separated file",
    "text": "From comma separated file\n\ndf = pd.read_csv(\"../tests/testdata/co2-mm-mlo.csv\", parse_dates=True, index_col='Date', na_values=-99.99)\ndf.head()\n\n\n\n\n\n  \n    \n      \n      Decimal Date\n      Average\n      Interpolated\n      Trend\n      Number of Days\n    \n    \n      Date\n      \n      \n      \n      \n      \n    \n  \n  \n    \n      1958-03-01\n      1958.208\n      315.71\n      315.71\n      314.62\n      -1\n    \n    \n      1958-04-01\n      1958.292\n      317.45\n      317.45\n      315.29\n      -1\n    \n    \n      1958-05-01\n      1958.375\n      317.50\n      317.50\n      314.71\n      -1\n    \n    \n      1958-06-01\n      1958.458\n      NaN\n      317.10\n      314.85\n      -1\n    \n    \n      1958-07-01\n      1958.542\n      315.86\n      315.86\n      314.98\n      -1\n    \n  \n\n\n\n\nRemove missing values\n\ndf = df.dropna()\ndf = df[[\"Average\",\"Trend\"]]\ndf.plot()\n\n<AxesSubplot: xlabel='Date'>\n\n\n\n\n\nA dataframe with a datetimeindex can be used to create a dfs 0 with a non-equidistant time axis.\n\ndf.to_dfs0(\"mauna_loa_co2.dfs0\")\n\nTo get a equidistant time axis first interpolate to hourly values.\n\ndf_h = df.resample('h').interpolate()\n\n\ndf_h.to_dfs0(\"mauna_loa_co2_eq_1hr.dfs0\")"
  },
  {
    "objectID": "notebooks/Dfs0 - Timeseries.html#or-as-a-pandas-dataframe",
    "href": "notebooks/Dfs0 - Timeseries.html#or-as-a-pandas-dataframe",
    "title": "mikeio-examples",
    "section": "Or as a Pandas dataframe",
    "text": "Or as a Pandas dataframe\nA mikeio.Dataset ds is converted to a pandas dataframe with ds.to_dataframe()\n\ndfs0file = \"../tests/testdata/da_diagnostic.dfs0\"\ndf = mikeio.read(dfs0file).to_dataframe()\ndf.head()\n\n\n\n\n\n  \n    \n      \n      State 1Sign. Wave Height\n      State 2Sign. Wave Height\n      Mean StateSign. Wave Height\n      MeasurementSign. Wave Height\n    \n  \n  \n    \n      2017-10-27 00:00:00\n      1.749465\n      1.749465\n      1.749465\n      1.72\n    \n    \n      2017-10-27 00:10:00\n      1.811340\n      1.796895\n      1.807738\n      NaN\n    \n    \n      2017-10-27 00:20:00\n      1.863424\n      1.842759\n      1.853422\n      NaN\n    \n    \n      2017-10-27 00:30:00\n      1.922261\n      1.889839\n      1.897670\n      NaN\n    \n    \n      2017-10-27 00:40:00\n      1.972455\n      1.934886\n      1.935281\n      NaN\n    \n  \n\n\n\n\n\ndfs0file = \"../tests/testdata/random.dfs0\"\ndf = mikeio.read(dfs0file).to_dataframe()\ndf.head()\n\n\n\n\n\n  \n    \n      \n      VarFun01\n      NotFun\n    \n  \n  \n    \n      2017-01-01 00:00:00\n      0.843547\n      0.640486\n    \n    \n      2017-01-01 05:00:00\n      0.093729\n      0.653257\n    \n    \n      2017-01-01 10:00:00\n      NaN\n      NaN\n    \n    \n      2017-01-01 15:00:00\n      0.305065\n      0.214208\n    \n    \n      2017-01-01 20:00:00\n      0.900190\n      0.999157"
  },
  {
    "objectID": "notebooks/Dfs0 - Timeseries.html#create-a-timeseries-with-non-equidistant-data",
    "href": "notebooks/Dfs0 - Timeseries.html#create-a-timeseries-with-non-equidistant-data",
    "title": "mikeio-examples",
    "section": "Create a timeseries with non-equidistant data",
    "text": "Create a timeseries with non-equidistant data\n\nd1 = np.random.uniform(low=0.0, high=5.0, size=5)\ntime = pd.DatetimeIndex([\"2000-1-1\", \"2000-1-8\", \"2000-1-10\", \"2000-2-22\", \"2000-11-29\"])\nda = mikeio.DataArray(d1, time=time, item=ItemInfo(\"Random\"))\nda\n\n<mikeio.DataArray>\nname: Random\ndims: (time:5)\ntime: 2000-01-01 00:00:00 - 2000-11-29 00:00:00 (5 non-equidistant records)\nvalues: [3.747, 2.771, ..., 2.366]\n\n\n\nda.is_equidistant\n\nFalse\n\n\n\nda.to_dfs(\"neq.dfs0\", title=\"Non equidistant\")"
  },
  {
    "objectID": "notebooks/Dfs0 - Timeseries.html#create-a-timeseries-with-accumulated-timestep",
    "href": "notebooks/Dfs0 - Timeseries.html#create-a-timeseries-with-accumulated-timestep",
    "title": "mikeio-examples",
    "section": "Create a timeseries with accumulated timestep",
    "text": "Create a timeseries with accumulated timestep"
  },
  {
    "objectID": "notebooks/Dfs0 - Timeseries.html#find-correct-eum-units",
    "href": "notebooks/Dfs0 - Timeseries.html#find-correct-eum-units",
    "title": "mikeio-examples",
    "section": "Find correct eum units",
    "text": "Find correct eum units\n\nEUMType.search(\"prec\")\n\n[Correction of precipitation,\n Precipitation correction,\n Precipitation,\n Specific Precipitation,\n Precipitation Rate]\n\n\n\nEUMType.Precipitation_Rate.units\n\n[mm per day,\n mm per hour,\n cm per hour,\n meter per sec,\n meter per day,\n feet per day,\n inch per hour,\n inch per min,\n inch per day,\n mm per year]\n\n\n\nfrom mikecore.DfsFile import DataValueType\n\nn= 1000\ntime = pd.date_range(\"2017-01-01 00:00\", freq='H', periods=n)\n\n# use default name and unit based on type\nitem = ItemInfo(EUMType.Water_Level, data_value_type=DataValueType.Instantaneous)\nda1 = mikeio.DataArray(data=np.random.random([n]), time=time, item=item)\n\n# use a custom name\nitem = ItemInfo(\"Nedbør\", EUMType.Precipitation_Rate, data_value_type=DataValueType.Accumulated)\nda2 = mikeio.DataArray(data=np.random.random([n]), time=time, item=item)\n\nds = mikeio.Dataset([da1, da2])\nds.to_dfs('accumulated.dfs0')\n\n\nds = mikeio.read(\"accumulated.dfs0\")\nds\n\n<mikeio.Dataset>\ndims: (time:1000)\ntime: 2017-01-01 00:00:00 - 2017-02-11 15:00:00 (1000 records)\nitems:\n  0:  Water Level <Water Level> (meter)\n  1:  Nedbør <Precipitation Rate> (mm per day) - 1"
  },
  {
    "objectID": "notebooks/Dfs0 - Timeseries.html#convert-units",
    "href": "notebooks/Dfs0 - Timeseries.html#convert-units",
    "title": "mikeio-examples",
    "section": "Convert units",
    "text": "Convert units\nRead a file with waterlevel i meters.\n\nfilename = \"../tests/testdata/waterlevel_viken.dfs0\"\n# filename = r\"C:\\Program Files (x86)\\DHI\\MIKE Zero\\2021\\Examples\\MIKE_21\\FlowModel_FM\\HD\\Oresund\\Data\\1993\\Boundary_Conditions\\waterlevel_viken.dfs0\"\nds = mikeio.read(filename)\nds\n\n<mikeio.Dataset>\ndims: (time:577)\ntime: 1993-12-02 00:00:00 - 1993-12-14 00:00:00 (577 records)\nitems:\n  0:  ST 2: WL (m) <Water Level> (meter)\n\n\n\nds.plot()\n\n\n\n\nThe aim is to convert this timeseries to feet (1m = 3.3 ft)\n\nds[0] = ds[0]*3.3\n\nWhich units are acceptable?\n\nds.items[0].type.units\n\n[meter,\n kilometer,\n centimeter,\n millimeter,\n feet,\n feet US,\n inch,\n inch US,\n mile,\n mile US,\n yard,\n yard US]\n\n\n\nds[0].item = ItemInfo(\"Viken\", ds[0].item.type, EUMUnit.feet)\n\n\nds.to_dfs(\"wl_feet.dfs0\")\n\n\n\n\nWL"
  },
  {
    "objectID": "notebooks/Dfs0 - Timeseries.html#extrapolation",
    "href": "notebooks/Dfs0 - Timeseries.html#extrapolation",
    "title": "mikeio-examples",
    "section": "Extrapolation",
    "text": "Extrapolation\n\n# filename = r\"C:\\Program Files (x86)\\DHI\\MIKE Zero\\2021\\Examples\\MIKE_21\\FlowModel_FM\\HD\\Oresund\\Data\\1993\\Boundary_Conditions\\waterlevel_viken.dfs0\"\nfilename = \"../tests/testdata/waterlevel_viken.dfs0\"\nds = mikeio.read(filename)\ndf = ds.to_dataframe()\ndf.plot()\n\n<AxesSubplot: >\n\n\n\n\n\n\nrng = pd.date_range(\"1993-12-1\",\"1994-1-1\",freq='30t')\nix = pd.DatetimeIndex(rng)\ndfr = df.reindex(ix)\ndfr.plot()\n\n<AxesSubplot: >\n\n\n\n\n\nReplace NaN with constant extrapolation (forward fill + back fill).\n\ndfr = dfr.ffill().bfill()\ndfr.plot()\n\n<AxesSubplot: >\n\n\n\n\n\n\ndfr.to_dfs0(\"Viken_extrapolated.dfs0\", \n            items=ds.items, \n            title=\"Caution extrapolated data!\"\n            )"
  },
  {
    "objectID": "notebooks/Dfs0 - Timeseries.html#clean-up",
    "href": "notebooks/Dfs0 - Timeseries.html#clean-up",
    "title": "mikeio-examples",
    "section": "Clean up",
    "text": "Clean up\n\nimport os\n\nos.remove(\"test.dfs0\")\nos.remove(\"modified.dfs0\")\nos.remove(\"neq.dfs0\")\nos.remove(\"accumulated.dfs0\")\nos.remove(\"wl_feet.dfs0\")\nos.remove(\"mauna_loa_co2_eq_1hr.dfs0\")\nos.remove(\"mauna_loa_co2.dfs0\")\nos.remove(\"Viken_extrapolated.dfs0\")"
  },
  {
    "objectID": "notebooks/Dfsu - Read.html",
    "href": "notebooks/Dfsu - Read.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "Create a new dfsu file\n\nSubset of items\nRenamed variables\n\nFirst inspect the source file:\n\nds = mikeio.read(\"../tests/testdata/HD2D.dfsu\")\nds\n\n<mikeio.Dataset>\ndims: (time:9, element:884)\ntime: 1985-08-06 07:00:00 - 1985-08-07 03:00:00 (9 records)\ngeometry: Dfsu2D (884 elements, 529 nodes)\nitems:\n  0:  Surface elevation <Surface Elevation> (meter)\n  1:  U velocity <u velocity component> (meter per sec)\n  2:  V velocity <v velocity component> (meter per sec)\n  3:  Current speed <Current Speed> (meter per sec)\n\n\n\noutfilename2 = \"HD2D_selected.dfsu\"\n\nnewds = ds[[\"U velocity\", \"V velocity\"]].rename({'U velocity': 'eastward_sea_water_velocity',\n                                                 'V velocity': 'northward_sea_water_velocity'})\nnewds\n\n<mikeio.Dataset>\ndims: (time:9, element:884)\ntime: 1985-08-06 07:00:00 - 1985-08-07 03:00:00 (9 records)\ngeometry: Dfsu2D (884 elements, 529 nodes)\nitems:\n  0:  eastward_sea_water_velocity <u velocity component> (meter per sec)\n  1:  northward_sea_water_velocity <v velocity component> (meter per sec)\n\n\n\nnewds.to_dfs(outfilename2)\n\nRead the newly created file to verify the contents.\n\nnewds2 = mikeio.read(outfilename2)\nnewds2\n\n<mikeio.Dataset>\ndims: (time:9, element:884)\ntime: 1985-08-06 07:00:00 - 1985-08-07 03:00:00 (9 records)\ngeometry: Dfsu2D (884 elements, 529 nodes)\nitems:\n  0:  eastward_sea_water_velocity <u velocity component> (meter per sec)\n  1:  northward_sea_water_velocity <v velocity component> (meter per sec)\n\n\n\n\nWrite mesh from dfsu file\nDon’t you have the original mesh? No problem - you can re-create it from the dfsu file…\n\noutmesh = 'mesh_from_HD2D.mesh'\nds.geometry.to_mesh(outmesh)\n\n\n\nClean up\n\nimport os\nos.remove(outfilename2)\nos.remove(outmesh)"
  },
  {
    "objectID": "notebooks/Dfs1 - Read.html",
    "href": "notebooks/Dfs1 - Read.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "import mikeio\n\n\nds = mikeio.read(\"../tests/testdata/random.dfs1\")\nds\n\n<mikeio.Dataset>\ndims: (time:100, x:3)\ntime: 2012-01-01 00:00:00 - 2012-01-01 00:19:48 (100 records)\ngeometry: Grid1D (n=3, dx=100)\nitems:\n  0:  testing water level <Water Level> (meter)\n\n\n\nds.geometry\n\n<mikeio.Grid1D>\nx: [0, 100, 200] (nx=3, dx=100)\n\n\n\nda = ds[\"testing water level\"]\n\n\nda.plot();\n\n\n\n\n\nda.isel(x=0).plot(title=\"First\");\n\n\n\n\n\nda.isel(x=-1).plot(title=\"Last\");\n\n\n\n\nExport a single point from the Dfs1 to Dfs0\n\nda.isel(x=0).to_dfs(\"random_0.dfs0\")\n\n\nmikeio.read(\"random_0.dfs0\")[0].plot();\n\n\n\n\n\nimport os\nos.remove(\"random_0.dfs0\")"
  },
  {
    "objectID": "notebooks/Dfsu - Distance to land.html",
    "href": "notebooks/Dfsu - Distance to land.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "Get a list of land nodes\n\nncland = msh.node_coordinates[msh.codes==1]\n\nplt.scatter(ncland[:,0], ncland[:,1]);\n\n\n\n\n\n\nGet element coordinates\n\nec = msh.element_coordinates\n\n\n\nCalculate distance to nearest land node\n\ni = 0\nne = ec.shape[0]\nd = np.zeros(ne)\n\nfor i in range(ne):\n    d[i] = np.min(np.sqrt((ec[i,0] - ncland[:,0])**2 + (ec[i,1] -ncland[:,1])**2))\n\n\nda = mikeio.DataArray(data=d,\n                      geometry=msh.geometry,\n                      item=mikeio.ItemInfo(\"Distance to land\", mikeio.EUMType.Distance, mikeio.EUMUnit.meter))\nda\n\n<mikeio.DataArray>\nname: Distance to land\ndims: (element:654)\ntime: 2018-01-01 00:00:00 (time-invariant)\ngeometry: Dfsu2D (654 elements, 399 nodes)\nvalues: [1697, 435, ..., 1194]\n\n\n\nda.plot();\n\n\n\n\n\n\nStore result in a new Dfsu file\n\nda.to_dfs(\"distance.dfsu\")\n\n\n\nClean up\n\nimport os\nos.remove(\"distance.dfsu\")"
  },
  {
    "objectID": "notebooks/Dfsu - Spectral data.html",
    "href": "notebooks/Dfsu - Spectral data.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "MIKE 21 SW can output full spectral information in points, along lines or in an area. In all these cases data are stored in dfsu files with additional axes: frequency and directions.\nThis notebook explores reading full spectral dfsu files from MIKE 21 SW as\n\npoint\nline\narea\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport mikeio\n\n\n\n\nfn = \"../tests/testdata/pt_spectra.dfsu\"\nda = mikeio.read(fn)[0]\nda\n\n<mikeio.DataArray>\nname: Point 1: Energy density\ndims: (time:31, direction:16, frequency:25)\ntime: 2017-10-27 00:00:00 - 2017-10-27 05:00:00 (31 records)\ngeometry: Point Spectrum Geometry(frequency:25, direction:16)\n\n\n\nda.plot(); # plots first timestep by default\n\n\n\n\nDon’t like the default plot? No worries, it can be customized.\n\nax = da.plot.patch(rmax=8);\ndird = np.round(da.directions, 2)\nax.set_thetagrids(dird, labels=dird);\n\n\n\n\n\n\n\nData in dfsu line spectra is node-based contrary to must other dfsu-formats.\n\nfn = \"../tests/testdata/line_spectra.dfsu\"\nda = mikeio.read(fn).Energy_density\nda\n\n<mikeio.DataArray>\nname: Energy density\ndims: (time:4, node:10, direction:16, frequency:25)\ntime: 2017-10-27 00:00:00 - 2017-10-27 05:00:00 (4 records)\ngeometry: DfsuSpectral1D (9 elements, 10 nodes)\n\n\n\nspec = da[0].isel(node=3)  # note first 3 points are outside domain\nspec\n\n<mikeio.DataArray>\nname: Energy density\ndims: (direction:16, frequency:25)\ntime: 2017-10-27 00:00:00 (time-invariant)\ngeometry: Point Spectrum Geometry(frequency:25, direction:16, x:1.89843, y:51.69084)\n\n\n\nspec.plot(cmap=\"Greys\", rmax=8, r_as_periods=True);\n\n\n\n\n\n\n\nHm0 = da.isel(time=0).to_Hm0()\nHm0.plot(title='Hm0 on a line crossing the domain');\n\n\n\n\n\n\n\n\n\nfn = \"../tests/testdata/area_spectra.dfsu\"\nda = mikeio.read(fn, items=\"Energy density\")[0]\nda\n\n<mikeio.DataArray>\nname: Energy density\ndims: (time:3, element:40, direction:16, frequency:25)\ntime: 2017-10-27 00:00:00 - 2017-10-27 05:00:00 (3 records)\ngeometry: DfsuSpectral2D (40 elements, 33 nodes)\n\n\n\nda.plot(); # default area plot is Hm0\n\n\n\n\n\nda_pt = da.sel(x=2.9, y=52.5)\nda_pt\n\n<mikeio.DataArray>\nname: Energy density\ndims: (time:3, direction:16, frequency:25)\ntime: 2017-10-27 00:00:00 - 2017-10-27 05:00:00 (3 records)\ngeometry: Point Spectrum Geometry(frequency:25, direction:16, x:2.90053, y:52.47039)\n\n\n\nda_pt.plot(rmax=9);\n\n\n\n\n\n\n\nfrom ipywidgets import interact\nfrom datetime import timedelta\n\n\n@interact\ndef plot_element(id=(0,da.geometry.n_elements-1), step=(0,da.n_timesteps-1)):\n    spec = da[step,id]\n    time = da.start_time + timedelta(seconds=(step*da.timestep))\n    spec.plot(vmax=0.04, vmin=0, rmax=8, title=f\"Wave spectrum, {time}, element: {id}\");\n    plt.show();"
  },
  {
    "objectID": "notebooks/Time interpolation.html",
    "href": "notebooks/Time interpolation.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "Clean up\n\nimport os\nos.remove(\"waves_3h.dfs2\")"
  },
  {
    "objectID": "notebooks/Dfsu - 2D interpolation.html",
    "href": "notebooks/Dfsu - 2D interpolation.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "This notebook demonstrates how to interpolate dfsu data to a grid, how to save the gridded data as dfs2 and geotiff. It also shows how to interpolate dfsu data to another mesh.\n\nimport mikeio\n\n\nds = mikeio.read(\"../tests/testdata/wind_north_sea.dfsu\", items=\"Wind speed\")\nds\n\n<mikeio.Dataset>\ndims: (time:6, element:958)\ntime: 2017-10-27 00:00:00 - 2017-10-27 05:00:00 (6 records)\ngeometry: Dfsu2D (958 elements, 570 nodes)\nitems:\n  0:  Wind speed <Wind speed> (meter per sec)\n\n\n\nda = ds.Wind_speed\nda.plot();\n\n\n\n\n\n\n\nGet an overset grid covering the domain\nThen interpolate all data to the new grid and plot.\nThe interpolated data is then saved to a dfs2 file.\n\n\ng = da.geometry.get_overset_grid(dx=0.1)\ng\n\n<mikeio.Grid2D>\naxis: nx=105 points from x0=-1.56307 to x1=8.83693 with dx=0.1\naxis: ny=55 points from y0=49.8999 to y1=55.2999 with dy=0.1\n\n\n\nda_grid = da.interp_like(g)\nda_grid\n\n<mikeio.DataArray>\nname: Wind speed\ndims: (time:6, y:55, x:105)\ntime: 2017-10-27 00:00:00 - 2017-10-27 05:00:00 (6 records)\ngeometry: Grid2D (ny=55, nx=105)\n\n\n\nda_grid.plot();\n\n\n\n\n\n\n\n\nda_grid.to_dfs(\"wind_north_sea_interpolated.dfs2\")\n\n\n\n\n\n\nxr_da = da_grid.to_xarray()\nxr_da.to_netcdf(\"wind_north_sea_interpolated.nc\")\n\n\n\n\n\nInstall rasterio by running this in a command prompt before running this notebook\nconda install -c conda-forge rasterio\nOr if you prefer to avoid conda, here is how: https://rasterio.readthedocs.io/en/latest/installation.html#windows\n\nimport numpy as np\nimport rasterio\nfrom rasterio.transform import from_origin\n# Dcoumentation https://rasterio.readthedocs.io/en/latest/index.html\n\nwith rasterio.open(\n     'wind.tif',\n     'w',\n     driver='GTiff',\n     height=g.ny,\n     width=g.nx,\n     count=1,\n     dtype=da.dtype,\n     crs='+proj=latlong',\n     transform=from_origin(g.bbox.left, g.bbox.top, g.dx, g.dy)\n     ) as dst:\n        dst.write(np.flipud(da_grid[0].to_numpy()), 1) # first time_step"
  },
  {
    "objectID": "notebooks/Dfsu - 2D interpolation.html#interpolate-scatter-data-to-mesh",
    "href": "notebooks/Dfsu - 2D interpolation.html#interpolate-scatter-data-to-mesh",
    "title": "mikeio-examples",
    "section": "Interpolate scatter data to mesh",
    "text": "Interpolate scatter data to mesh\nWe want to interpolate scatter data onto an existing mesh and create a new dfsu with the interpolated data.\n\nfrom mikeio.spatial.utils import dist_in_meters\nfrom mikeio.interpolation import get_idw_interpolant\n\n\ndfs = mikeio.open('../tests/testdata/wind_north_sea.dfsu')\n\n\ndfs.geometry.plot.mesh();\n\n\n\n\n\n# scatter data: x,y,value for 4 points\nscatter= np.array([[1,50,1], [4, 52, 3], [8, 55, 2], [-1, 55, 1.5]])\nscatter\n\narray([[ 1. , 50. ,  1. ],\n       [ 4. , 52. ,  3. ],\n       [ 8. , 55. ,  2. ],\n       [-1. , 55. ,  1.5]])\n\n\nLet’s first try the approx for a single element:\n\ncalc distance to all interpolation points\ncalc IDW interpolatant weights\nInterpolate\n\n\ndist = dist_in_meters(scatter[:,:2], dfs.element_coordinates[0,:2])\ndist\n\narray([4.00139539, 3.18881018, 6.58769411, 2.69722991])\n\n\n\nw = get_idw_interpolant(dist, p=2)\nw\n\narray([0.19438779, 0.30607974, 0.07171749, 0.42781498])\n\n\n\nnp.dot(scatter[:,2], w) # interpolated value in element 0\n\n1.8977844597276883\n\n\nLet’s do the same for all points in the mesh and plot in the end\n\ndati = np.zeros((1,dfs.n_elements))\nfor j in range(dfs.n_elements):\n    dist = dist_in_meters(scatter[:,:2], dfs.element_coordinates[j,:2])\n    w = get_idw_interpolant(dist, p=2)\n    dati[0,j] = np.dot(scatter[:,2], w)\n\n\nds = mikeio.Dataset(data=[dati], geometry=dfs.geometry, time=dfs.start_time)\nds\n\n<mikeio.Dataset>\ndims: (time:1, element:958)\ntime: 2017-10-27 00:00:00 (time-invariant)\ngeometry: Dfsu2D (958 elements, 570 nodes)\nitems:\n  0:  Item_1 <Undefined> (undefined)\n\n\n\nds[0].plot(title=\"Interpolated scatter data\");\n\n\n\n\n\nds.to_dfs(\"interpolated_scatter.dfsu\")"
  },
  {
    "objectID": "notebooks/Dfsu - 2D interpolation.html#clean-up",
    "href": "notebooks/Dfsu - 2D interpolation.html#clean-up",
    "title": "mikeio-examples",
    "section": "Clean up",
    "text": "Clean up\n\nimport os\n\nos.remove(\"wind_north_sea_interpolated.dfs2\")\nos.remove(\"wind_north_sea_interpolated.nc\")\nos.remove(\"wind.tif\")\nos.remove(\"interpolated_scatter.dfsu\")"
  },
  {
    "objectID": "notebooks/Dfs2 - Export to netcdf.html",
    "href": "notebooks/Dfs2 - Export to netcdf.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "Clean up\n\nimport os\nos.remove(\"gebco_std.nc\")\nos.remove(\"gebco.nc\")"
  },
  {
    "objectID": "notebooks/Dfs2 - Global Forecasting System.html",
    "href": "notebooks/Dfs2 - Global Forecasting System.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "import xarray\nimport pandas as pd\nimport mikeio\n\nThe file gfs_wind.nc contains a small sample of the GFS forecast data downloaded via their OpenDAP service\n\nds = xarray.open_dataset('../tests/testdata/gfs_wind.nc')\n\nRunning a Mike 21 HD model, needs at least three variables of meteorological forcing * Mean Sea Level Pressure * U 10m * V 10m\n\nds.msletmsl\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.DataArray 'msletmsl' (time: 3, lat: 41, lon: 21)>\narray([[[101116.35 , 101134.555, ..., 101474.15 , 101485.35 ],\n        [101122.95 , 101141.75 , ..., 101498.35 , 101509.15 ],\n        ...,\n        [101972.555, 102048.35 , ..., 101975.15 , 101966.15 ],\n        [102029.555, 102074.95 , ..., 101970.75 , 101953.15 ]],\n\n       [[100923.02 , 100932.43 , ..., 101305.43 , 101316.43 ],\n        [100940.625, 100945.625, ..., 101329.83 , 101343.625],\n        ...,\n        [101875.43 , 101861.83 , ..., 101870.83 , 101875.83 ],\n        [101912.43 , 101898.02 , ..., 101860.83 , 101876.83 ]],\n\n       [[101001.36 , 101014.555, ..., 101453.76 , 101465.555],\n        [101002.96 , 101017.96 , ..., 101513.36 , 101522.76 ],\n        ...,\n        [101853.36 , 101859.16 , ..., 101855.555, 101863.555],\n        [101870.36 , 101869.96 , ..., 101866.36 , 101870.96 ]]], dtype=float32)\nCoordinates:\n  * time     (time) datetime64[ns] 2021-09-02T12:00:00 ... 2021-09-02T18:00:00\n  * lat      (lat) float64 30.0 30.25 30.5 30.75 31.0 ... 39.25 39.5 39.75 40.0\n  * lon      (lon) float64 10.0 10.25 10.5 10.75 11.0 ... 14.25 14.5 14.75 15.0\nAttributes:\n    long_name:  ** mean sea level mslp (eta model reduction) [pa] xarray.DataArray'msletmsl'time: 3lat: 41lon: 211.011e+05 1.011e+05 1.011e+05 ... 1.018e+05 1.019e+05 1.019e+05array([[[101116.35 , 101134.555, ..., 101474.15 , 101485.35 ],\n        [101122.95 , 101141.75 , ..., 101498.35 , 101509.15 ],\n        ...,\n        [101972.555, 102048.35 , ..., 101975.15 , 101966.15 ],\n        [102029.555, 102074.95 , ..., 101970.75 , 101953.15 ]],\n\n       [[100923.02 , 100932.43 , ..., 101305.43 , 101316.43 ],\n        [100940.625, 100945.625, ..., 101329.83 , 101343.625],\n        ...,\n        [101875.43 , 101861.83 , ..., 101870.83 , 101875.83 ],\n        [101912.43 , 101898.02 , ..., 101860.83 , 101876.83 ]],\n\n       [[101001.36 , 101014.555, ..., 101453.76 , 101465.555],\n        [101002.96 , 101017.96 , ..., 101513.36 , 101522.76 ],\n        ...,\n        [101853.36 , 101859.16 , ..., 101855.555, 101863.555],\n        [101870.36 , 101869.96 , ..., 101866.36 , 101870.96 ]]], dtype=float32)Coordinates: (3)time(time)datetime64[ns]2021-09-02T12:00:00 ... 2021-09-...grads_dim :tgrads_mapping :lineargrads_size :129grads_min :12z02sep2021grads_step :3hrlong_name :timeminimum :12z02sep2021maximum :12z18sep2021resolution :0.125array(['2021-09-02T12:00:00.000000000', '2021-09-02T15:00:00.000000000',\n       '2021-09-02T18:00:00.000000000'], dtype='datetime64[ns]')lat(lat)float6430.0 30.25 30.5 ... 39.5 39.75 40.0grads_dim :ygrads_mapping :lineargrads_size :721units :degrees_northlong_name :latitudeminimum :-90.0maximum :90.0resolution :0.25array([30.  , 30.25, 30.5 , 30.75, 31.  , 31.25, 31.5 , 31.75, 32.  , 32.25,\n       32.5 , 32.75, 33.  , 33.25, 33.5 , 33.75, 34.  , 34.25, 34.5 , 34.75,\n       35.  , 35.25, 35.5 , 35.75, 36.  , 36.25, 36.5 , 36.75, 37.  , 37.25,\n       37.5 , 37.75, 38.  , 38.25, 38.5 , 38.75, 39.  , 39.25, 39.5 , 39.75,\n       40.  ])lon(lon)float6410.0 10.25 10.5 ... 14.5 14.75 15.0grads_dim :xgrads_mapping :lineargrads_size :1440units :degrees_eastlong_name :longitudeminimum :0.0maximum :359.75resolution :0.25array([10.  , 10.25, 10.5 , 10.75, 11.  , 11.25, 11.5 , 11.75, 12.  , 12.25,\n       12.5 , 12.75, 13.  , 13.25, 13.5 , 13.75, 14.  , 14.25, 14.5 , 14.75,\n       15.  ])Attributes: (1)long_name :** mean sea level mslp (eta model reduction) [pa] \n\n\n\nds.ugrd10m\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.DataArray 'ugrd10m' (time: 3, lat: 41, lon: 21)>\narray([[[ 1.021836,  1.151836, ..., -4.318164, -4.228164],\n        [ 1.731836,  1.361836, ..., -4.408164, -4.138164],\n        ...,\n        [-2.328164, -0.578164, ...,  0.111836,  1.381836],\n        [-1.368164, -0.248164, ...,  2.521836,  3.361836]],\n\n       [[-1.186663, -0.896663, ..., -4.376663, -4.216662],\n        [-0.516663, -0.106663, ..., -4.476663, -4.386662],\n        ...,\n        [-2.176662, -3.376662, ...,  2.673337,  3.193337],\n        [-1.596663, -2.376662, ...,  2.923337,  3.493337]],\n\n       [[-3.289988, -3.199988, ..., -5.399988, -5.479988],\n        [-3.449988, -3.719988, ..., -7.419988, -6.809988],\n        ...,\n        [-2.629988, -3.189988, ...,  2.280012,  2.160012],\n        [-1.719988, -2.939988, ...,  2.620012,  2.800012]]], dtype=float32)\nCoordinates:\n  * time     (time) datetime64[ns] 2021-09-02T12:00:00 ... 2021-09-02T18:00:00\n  * lat      (lat) float64 30.0 30.25 30.5 30.75 31.0 ... 39.25 39.5 39.75 40.0\n  * lon      (lon) float64 10.0 10.25 10.5 10.75 11.0 ... 14.25 14.5 14.75 15.0\nAttributes:\n    long_name:  ** 10 m above ground u-component of wind [m/s] xarray.DataArray'ugrd10m'time: 3lat: 41lon: 211.022 1.152 2.212 1.782 0.8518 1.172 ... 2.79 3.63 3.99 2.93 2.62 2.8array([[[ 1.021836,  1.151836, ..., -4.318164, -4.228164],\n        [ 1.731836,  1.361836, ..., -4.408164, -4.138164],\n        ...,\n        [-2.328164, -0.578164, ...,  0.111836,  1.381836],\n        [-1.368164, -0.248164, ...,  2.521836,  3.361836]],\n\n       [[-1.186663, -0.896663, ..., -4.376663, -4.216662],\n        [-0.516663, -0.106663, ..., -4.476663, -4.386662],\n        ...,\n        [-2.176662, -3.376662, ...,  2.673337,  3.193337],\n        [-1.596663, -2.376662, ...,  2.923337,  3.493337]],\n\n       [[-3.289988, -3.199988, ..., -5.399988, -5.479988],\n        [-3.449988, -3.719988, ..., -7.419988, -6.809988],\n        ...,\n        [-2.629988, -3.189988, ...,  2.280012,  2.160012],\n        [-1.719988, -2.939988, ...,  2.620012,  2.800012]]], dtype=float32)Coordinates: (3)time(time)datetime64[ns]2021-09-02T12:00:00 ... 2021-09-...grads_dim :tgrads_mapping :lineargrads_size :129grads_min :12z02sep2021grads_step :3hrlong_name :timeminimum :12z02sep2021maximum :12z18sep2021resolution :0.125array(['2021-09-02T12:00:00.000000000', '2021-09-02T15:00:00.000000000',\n       '2021-09-02T18:00:00.000000000'], dtype='datetime64[ns]')lat(lat)float6430.0 30.25 30.5 ... 39.5 39.75 40.0grads_dim :ygrads_mapping :lineargrads_size :721units :degrees_northlong_name :latitudeminimum :-90.0maximum :90.0resolution :0.25array([30.  , 30.25, 30.5 , 30.75, 31.  , 31.25, 31.5 , 31.75, 32.  , 32.25,\n       32.5 , 32.75, 33.  , 33.25, 33.5 , 33.75, 34.  , 34.25, 34.5 , 34.75,\n       35.  , 35.25, 35.5 , 35.75, 36.  , 36.25, 36.5 , 36.75, 37.  , 37.25,\n       37.5 , 37.75, 38.  , 38.25, 38.5 , 38.75, 39.  , 39.25, 39.5 , 39.75,\n       40.  ])lon(lon)float6410.0 10.25 10.5 ... 14.5 14.75 15.0grads_dim :xgrads_mapping :lineargrads_size :1440units :degrees_eastlong_name :longitudeminimum :0.0maximum :359.75resolution :0.25array([10.  , 10.25, 10.5 , 10.75, 11.  , 11.25, 11.5 , 11.75, 12.  , 12.25,\n       12.5 , 12.75, 13.  , 13.25, 13.5 , 13.75, 14.  , 14.25, 14.5 , 14.75,\n       15.  ])Attributes: (1)long_name :** 10 m above ground u-component of wind [m/s] \n\n\n\nds.vgrd10m\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.DataArray 'vgrd10m' (time: 3, lat: 41, lon: 21)>\narray([[[-0.474941, -0.634941, ..., -1.244941, -1.254941],\n        [-1.124941, -0.504941, ..., -1.014941, -1.224941],\n        ...,\n        [-0.454941,  1.145059, ...,  1.505059,  1.635059],\n        [ 1.695059,  2.595058, ...,  1.645059,  1.805059]],\n\n       [[-4.673393, -3.993393, ..., -2.993393, -3.323394],\n        [-4.393394, -4.633393, ..., -2.723393, -3.213393],\n        ...,\n        [-0.593394,  0.456606, ...,  0.616606, -0.323394],\n        [ 0.046606,  1.156606, ...,  0.066606, -1.213394]],\n\n       [[-2.777568, -3.487568, ..., -4.187568, -4.807568],\n        [-1.427568, -1.767568, ..., -5.827568, -6.177568],\n        ...,\n        [-1.707568, -1.177568, ..., -2.307568, -2.357568],\n        [-2.577568, -1.327568, ..., -2.947568, -3.897568]]], dtype=float32)\nCoordinates:\n  * time     (time) datetime64[ns] 2021-09-02T12:00:00 ... 2021-09-02T18:00:00\n  * lat      (lat) float64 30.0 30.25 30.5 30.75 31.0 ... 39.25 39.5 39.75 40.0\n  * lon      (lon) float64 10.0 10.25 10.5 10.75 11.0 ... 14.25 14.5 14.75 15.0\nAttributes:\n    long_name:  ** 10 m above ground v-component of wind [m/s] xarray.DataArray'vgrd10m'time: 3lat: 41lon: 21-0.4749 -0.6349 -0.9649 -0.3649 1.155 ... -0.9676 -1.868 -2.948 -3.898array([[[-0.474941, -0.634941, ..., -1.244941, -1.254941],\n        [-1.124941, -0.504941, ..., -1.014941, -1.224941],\n        ...,\n        [-0.454941,  1.145059, ...,  1.505059,  1.635059],\n        [ 1.695059,  2.595058, ...,  1.645059,  1.805059]],\n\n       [[-4.673393, -3.993393, ..., -2.993393, -3.323394],\n        [-4.393394, -4.633393, ..., -2.723393, -3.213393],\n        ...,\n        [-0.593394,  0.456606, ...,  0.616606, -0.323394],\n        [ 0.046606,  1.156606, ...,  0.066606, -1.213394]],\n\n       [[-2.777568, -3.487568, ..., -4.187568, -4.807568],\n        [-1.427568, -1.767568, ..., -5.827568, -6.177568],\n        ...,\n        [-1.707568, -1.177568, ..., -2.307568, -2.357568],\n        [-2.577568, -1.327568, ..., -2.947568, -3.897568]]], dtype=float32)Coordinates: (3)time(time)datetime64[ns]2021-09-02T12:00:00 ... 2021-09-...grads_dim :tgrads_mapping :lineargrads_size :129grads_min :12z02sep2021grads_step :3hrlong_name :timeminimum :12z02sep2021maximum :12z18sep2021resolution :0.125array(['2021-09-02T12:00:00.000000000', '2021-09-02T15:00:00.000000000',\n       '2021-09-02T18:00:00.000000000'], dtype='datetime64[ns]')lat(lat)float6430.0 30.25 30.5 ... 39.5 39.75 40.0grads_dim :ygrads_mapping :lineargrads_size :721units :degrees_northlong_name :latitudeminimum :-90.0maximum :90.0resolution :0.25array([30.  , 30.25, 30.5 , 30.75, 31.  , 31.25, 31.5 , 31.75, 32.  , 32.25,\n       32.5 , 32.75, 33.  , 33.25, 33.5 , 33.75, 34.  , 34.25, 34.5 , 34.75,\n       35.  , 35.25, 35.5 , 35.75, 36.  , 36.25, 36.5 , 36.75, 37.  , 37.25,\n       37.5 , 37.75, 38.  , 38.25, 38.5 , 38.75, 39.  , 39.25, 39.5 , 39.75,\n       40.  ])lon(lon)float6410.0 10.25 10.5 ... 14.5 14.75 15.0grads_dim :xgrads_mapping :lineargrads_size :1440units :degrees_eastlong_name :longitudeminimum :0.0maximum :359.75resolution :0.25array([10.  , 10.25, 10.5 , 10.75, 11.  , 11.25, 11.5 , 11.75, 12.  , 12.25,\n       12.5 , 12.75, 13.  , 13.25, 13.5 , 13.75, 14.  , 14.25, 14.5 , 14.75,\n       15.  ])Attributes: (1)long_name :** 10 m above ground v-component of wind [m/s] \n\n\n\nds.ugrd10m[0].plot();\n\n\n\n\n\n\n\n\n\n\ntime = pd.DatetimeIndex(ds.time)\ntime\n\nDatetimeIndex(['2021-09-02 12:00:00', '2021-09-02 15:00:00',\n               '2021-09-02 18:00:00'],\n              dtype='datetime64[ns]', freq=None)\n\n\n\n\n\n\nmikeio.EUMType.Air_Pressure\n\nAir Pressure\n\n\n\nmikeio.EUMType.Air_Pressure.units\n\n[hectopascal, millibar]\n\n\n\nmikeio.EUMType.Wind_Velocity\n\nWind Velocity\n\n\n\nmikeio.EUMType.Wind_Velocity.units\n\n[meter per sec, feet per sec, miles per hour, km per hour, knot]\n\n\n\nmslp = ds.msletmsl.values / 100 # conversion from Pa to hPa\nu = ds.ugrd10m.values\nv = ds.vgrd10m.values\n\n\ngeometry = mikeio.Grid2D(x=ds.lon.values, y=ds.lat.values, projection=\"LONG/LAT\")\ngeometry\n\n<mikeio.Grid2D>\nx: [10, 10.25, ..., 15] (nx=21, dx=0.25)\ny: [30, 30.25, ..., 40] (ny=41, dy=0.25)\nprojection: LONG/LAT\n\n\n\nfrom mikeio import ItemInfo, EUMType, EUMUnit\n\nmslp_da = mikeio.DataArray(data=mslp,time=time, geometry=geometry, item=ItemInfo(\"Mean Sea Level Pressure\", EUMType.Air_Pressure, EUMUnit.hectopascal))\nu_da = mikeio.DataArray(data=u,time=time, geometry=geometry, item=ItemInfo(\"Wind U\", EUMType.Wind_Velocity, EUMUnit.meter_per_sec))\nv_da = mikeio.DataArray(data=v,time=time, geometry=geometry, item=ItemInfo(\"Wind V\", EUMType.Wind_Velocity, EUMUnit.meter_per_sec))\n\n\nmds = mikeio.Dataset([mslp_da, u_da, v_da])\nmds\n\n<mikeio.Dataset>\ndims: (time:3, y:41, x:21)\ntime: 2021-09-02 12:00:00 - 2021-09-02 18:00:00 (3 records)\ngeometry: Grid2D (ny=41, nx=21)\nitems:\n  0:  Mean Sea Level Pressure <Air Pressure> (hectopascal)\n  1:  Wind U <Wind Velocity> (meter per sec)\n  2:  Wind V <Wind Velocity> (meter per sec)\n\n\n\nmds.to_dfs(\"gfs.dfs2\")\n\n\n\n\n\nimport os\nos.remove(\"gfs.dfs2\")"
  },
  {
    "objectID": "notebooks/DataArray - Masking.html",
    "href": "notebooks/DataArray - Masking.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "Similar to numpy arrays, DataArrays can be filtered based on values (e.g. all values above a threshold), which will return a DataArray with boolean values.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport mikeio\n\n\n\nRead 3 timesteps of Surface elevation from dfsu2d file.\n\nfn = \"../tests/testdata/oresundHD_run1.dfsu\"\nda = mikeio.read(fn, items=\"Surface elevation\", time=[0,2,4])[0]\nda\n\n<mikeio.DataArray>\nname: Surface elevation\ndims: (time:3, element:3612)\ntime: 2018-03-07 00:00:00 - 2018-03-11 00:00:00 (3 records)\ngeometry: Dfsu2D (3612 elements, 2046 nodes)\n\n\n\n_, ax = plt.subplots(1, da.n_timesteps, figsize=(11,5), sharey=True)\nfor step in range(da.n_timesteps):\n    da[step].plot(ax=ax[step], vmin=0.08, vmax=0.35)\n\n\n\n\n\n\n\nAssume that we are not interested in values below 0.2m. Let us find those and call the DataArray mask.\n\nthreshold = 0.2\nmask = da<threshold\nmask\n\n<mikeio.DataArray>\nname: Boolean\ndims: (time:3, element:3612)\ntime: 2018-03-07 00:00:00 - 2018-03-11 00:00:00 (3 records)\ngeometry: Dfsu2D (3612 elements, 2046 nodes)\n\n\nNow let’s set define a new DataArray wl_capped for which we set all values below the threshold to NaN.\n\nwl_capped = da.copy()\nwl_capped[mask] = np.nan\nwl_capped\n\n<mikeio.DataArray>\nname: Surface elevation\ndims: (time:3, element:3612)\ntime: 2018-03-07 00:00:00 - 2018-03-11 00:00:00 (3 records)\ngeometry: Dfsu2D (3612 elements, 2046 nodes)\n\n\nNow let’s plot both the boolean mask and the new capped DataArray for each of the three timesteps\n\n_, ax = plt.subplots(2, da.n_timesteps, figsize=(11,10), sharey=True)\nfor step in range(da.n_timesteps):\n    mask[step].plot(ax=ax[0,step], cmap=\"Reds\", add_colorbar=False)\n    wl_capped[step].plot(ax=ax[1,step], vmin=0.08, vmax=0.35)\n\n\n\n\n\n\n\nThe boolean indexing can also be done with a plain numpy array (it does not need to be a mikeio.DataArray).\nIn this example, we set all elements with depth lower than -10m to NaN.\n\nze = da.geometry.element_coordinates[:,2]\nze.shape\n\n(3612,)\n\n\n\nwl_shallow = da.copy()\nwl_shallow[ze<-10] = np.nan  # select all elements with depth lower than -10m\nwl_shallow.shape\n\n(3, 3612)\n\n\n\nwl_shallow.plot();"
  },
  {
    "objectID": "notebooks/Dataset - Add item.html",
    "href": "notebooks/Dataset - Add item.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "A common workflow is to create a new item based on existing items in a dataset.\nThis can be in done in several ways. Let’s try one of the options.\n\nimport numpy as np\nimport mikeio\n\n\nds = mikeio.read(\"../tests/testdata/NorthSea_HD_and_windspeed.dfsu\")\nds\n\n<mikeio.Dataset>\ndims: (time:67, element:958)\ntime: 2017-10-27 00:00:00 - 2017-10-29 18:00:00 (67 records)\ngeometry: Dfsu2D (958 elements, 570 nodes)\nitems:\n  0:  Surface elevation <Surface Elevation> (meter)\n  1:  Wind speed <Wind speed> (meter per sec)\n\n\n\nCreate a copy of the DataArray\n\n\nws2 = ds.Wind_speed.copy()\nws2.plot.hist();\n\n\n\n\n\nMake some modifications\n\n\nws2.values = np.clip(ws2.values, 1,18)\nws2.plot.hist();\n\n\n\n\n\nAssign it to a new name in the dataset\n\n\nds[\"Wind speed 2\"] = ws2\n\n\nds\n\n<mikeio.Dataset>\ndims: (time:67, element:958)\ntime: 2017-10-27 00:00:00 - 2017-10-29 18:00:00 (67 records)\ngeometry: Dfsu2D (958 elements, 570 nodes)\nitems:\n  0:  Surface elevation <Surface Elevation> (meter)\n  1:  Wind speed <Wind speed> (meter per sec)\n  2:  Wind speed 2 <Wind speed> (meter per sec)\n\n\n\nReorder items if necessary\n\n\nds2 = ds[[\"Wind speed 2\",\"Surface elevation\", \"Wind speed\"]]\nds2\n\n<mikeio.Dataset>\ndims: (time:67, element:958)\ntime: 2017-10-27 00:00:00 - 2017-10-29 18:00:00 (67 records)\ngeometry: Dfsu2D (958 elements, 570 nodes)\nitems:\n  0:  Wind speed 2 <Wind speed> (meter per sec)\n  1:  Surface elevation <Surface Elevation> (meter)\n  2:  Wind speed <Wind speed> (meter per sec)\n\n\n\nds2.to_dfs(\"modified.dfsu\")"
  },
  {
    "objectID": "notebooks/Dfsu - 3D sigma-z.html",
    "href": "notebooks/Dfsu - 3D sigma-z.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "Read 1D profile from 3D file\nFind water column which has highest temperature and plot profile for all 3 time steps.\n\ndsp = dfs.read(x=max_x, y=max_y) # select vertical column from dfsu-3d \ndsp[\"Temperature\"].plot();\n\n\n\n\nNote that the vertical column data is extrapolated to the bottom and surface!\nThe extrapolation can avoided using “extrapolate=False”:\n\ndsp[\"Temperature\"].plot(extrapolate=False, marker='o');\n\n\n\n\nIf the data has more than a few timesteps, it can be more convenient to plot as 2d pcolormesh. We will simulate this by interpolating to 30min data.\nNote that pcolormesh will plot using the static z information!\n\ndspi = dsp.Salinity.interp_time(dt=1800)\ndspi.plot.pcolormesh();\n\n\n\n\n\n\nRead top layer of a smaller area\n\nbbox = [310000, 6192000, 380000, 6198000]\nds_sub = dfs.read(area=bbox, layers=\"top\")\nds_sub\n\n<mikeio.Dataset>\ndims: (time:3, element:118)\ntime: 1997-09-15 21:00:00 - 1997-09-16 03:00:00 (3 records)\ngeometry: Dfsu2D (118 elements, 87 nodes)\nitems:\n  0:  Temperature <Temperature> (degree Celsius)\n  1:  Salinity <Salinity> (PSU)\n\n\n\nds_sub.Temperature.plot();\n\n\n\n\nPlot subset inside original model domain\n\nax = ds_sub.Temperature.plot(figsize=(6,7))\ndfs.geometry.plot.outline(ax=ax, title=None);\n\n\n\n\n\nds_sub.to_dfs(\"oresund_data_extracted.dfsu\")\n\n\n\nSelect top 2 layers and write to new file\nget_layer_elements() can take a list of layers. Layers are counted positive from the bottom starting at 0 or alternatively counted negative from the top starting at -1. Here we take layers -1 and -2, i.e., the two top layers.\nNext data is read from source file and finally written to a new dfsu file (which is now sigma-only dfsu file).\n\nds_top2 = dfs.read(layers=[-2, -1])\nds_top2\n\n<mikeio.Dataset>\ndims: (time:3, element:7400)\ntime: 1997-09-15 21:00:00 - 1997-09-16 03:00:00 (3 records)\ngeometry: Dfsu3DSigma (7400 elements, 2 sigma-layers, 0 z-layers)\nitems:\n  0:  Temperature <Temperature> (degree Celsius)\n  1:  Salinity <Salinity> (PSU)\n\n\n\noutfile = \"oresund_top2_layers.dfsu\"\nds_top2.to_dfs(outfile)\n\n\n\nRead vertical slice (transect)\n\nfilename = \"../tests/testdata/oresund_vertical_slice.dfsu\"\nds = mikeio.read(filename)\nds\n\n<mikeio.Dataset>\ndims: (time:3, element:441)\ntime: 1997-09-15 21:00:00 - 1997-09-16 03:00:00 (3 records)\ngeometry: DfsuVerticalProfileSigmaZ (441 elements, 4 sigma-layers, 5 z-layers)\nitems:\n  0:  Temperature <Temperature> (degree Celsius)\n  1:  Salinity <Salinity> (PSU)\n\n\n\nprint(ds.geometry.bottom_elements[:9])\nprint(ds.geometry.n_layers_per_column[:9])\nprint(ds.geometry.top_elements[:9])\n\n[ 0  5 10 15 20 24 28 32 36]\n[5 5 5 5 4 4 4 4 4]\n[ 4  9 14 19 23 27 31 35 39]\n\n\n\nds.Temperature.plot();\n\n\n\n\n\n\nClean up\n\nimport os\nos.remove(\"mesh_oresund_extracted.mesh\")\nos.remove(\"oresund_data_extracted.dfsu\")\nos.remove(\"oresund_top2_layers.dfsu\")"
  },
  {
    "objectID": "notebooks/PFS.html",
    "href": "notebooks/PFS.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "The support for PFS files have been extended with MIKE IO release 1.2. It was previously only possible to read PFS files. It is now also possible to modify and create new PFS files.\n\nimport mikeio\n\n\n\n\npfs = mikeio.read_pfs(\"../tests/testdata/pfs/lake.sw\")\npfs\n\n<mikeio.Pfs>\nFemEngineSW: DOMAIN:  Touched: 1  discretization: 2  numbe...\n\n\nThe “target” (root section) is in this case called FemEngineSW. pfs.FemEngineSW is a PfsSection object that contains other PfsSection objects. Let’s print the names of it’s subsections:\n\npfs.FemEngineSW.keys()\n\ndict_keys(['DOMAIN', 'TIME', 'MODULE_SELECTION', 'SPECTRAL_WAVE_MODULE'])\n\n\nIt is possible to navigate to each section and keyword in the pfs file:\n\npfs.FemEngineSW.DOMAIN.file_name\n\n'|.\\\\Lake_Mesh.mesh|'\n\n\n\npfs.FemEngineSW.MODULE_SELECTION\n\nTouched: 0\nmode_of_hydrodynamic_module: 0\nhydrodynamic_features: 1\nfluid_property: 1\nmode_of_spectral_wave_module: 2\nmode_of_transport_module: 0\nmode_of_mud_transport_module: 0\nmode_of_eco_lab_module: 0\nmode_of_sand_transport_module: 0\nmode_of_particle_tracking_module: 0\nmode_of_oil_spill_module: 0\nmode_of_shoreline_module: 0\n\n\n\npfs.FemEngineSW.MODULE_SELECTION.mode_of_spectral_wave_module\n\n2\n\n\nMIKE FM PFS files has a specific structure and active FM modules can be accessed by an alias on the Pfs object. In this case, pfs.SW can be used as a short-hand for pfs.FemEngineSW.SPECTRAL_WAVE_MODULE.\n\npfs.SW.SPECTRAL.number_of_directions\n\n16\n\n\n\npfs.SW.SPECTRAL.maximum_threshold_frequency\n\n0.5959088268863615\n\n\nEnumerated sections (e.g. [OUTPUT_1], [OUTPUT_2], …) can be outputted in tabular form (dataframe).\n\ndf = pfs.SW.OUTPUTS.to_dataframe()\ndf\n\n\n\n\n\n  \n    \n      \n      Touched\n      include\n      title\n      file_name\n      type\n      format\n      flood_and_dry\n      coordinate_type\n      zone\n      input_file_name\n      ...\n      last_time_step\n      time_step_frequency\n      number_of_points\n      POINT_1\n      LINE\n      AREA\n      INTEGRAL_WAVE_PARAMETERS\n      INPUT_PARAMETERS\n      MODEL_PARAMETERS\n      SPECTRAL_PARAMETERS\n    \n  \n  \n    \n      1\n      1\n      1\n      Wave parameters in domain\n      Wave_parameters.dfsu\n      1\n      2\n      2\n      UTM-32\n      0\n      ||\n      ...\n      450\n      10\n      1\n      {'name': 'POINT_1', 'x': 20000.0, 'y': 20000.0}\n      {'npoints': 3, 'x_first': 0.0, 'y_first': 0.0,...\n      {'number_of_points': 4, 'POINT_1': {'x': -400....\n      {'Touched': 1, 'type_of_spectrum': 1, 'minimum...\n      {'Touched': 1, 'Surface_elevation': 0, 'Water_...\n      {'Touched': 1, 'Wind_friction_speed': 0, 'Roug...\n      {'Touched': 1, 'separation_of_wind_sea_and_swe...\n    \n    \n      2\n      1\n      0\n      Wave parameters along line\n      Wave_line.dfs1\n      1\n      1\n      2\n      UTM-32\n      0\n      ||\n      ...\n      450\n      10\n      1\n      {'name': 'POINT_1', 'x': 20000.0, 'y': 20000.0}\n      {'npoints': 41, 'x_first': 0.0, 'y_first': 200...\n      {'number_of_points': 4, 'POINT_1': {'x': -400....\n      {'Touched': 1, 'type_of_spectrum': 1, 'minimum...\n      {'Touched': 1, 'Surface_elevation': 0, 'Water_...\n      {'Touched': 1, 'Wind_friction_speed': 0, 'Roug...\n      {'Touched': 1, 'separation_of_wind_sea_and_swe...\n    \n    \n      3\n      1\n      1\n      Wave parameters  in a point\n      Waves_x20km_y20km.dfs0\n      1\n      0\n      2\n      UTM-32\n      0\n      ||\n      ...\n      450\n      1\n      1\n      {'name': 'POINT_1', 'x': 38000.0, 'y': 20000.0}\n      {'npoints': 3, 'x_first': 0.0, 'y_first': 0.0,...\n      {'number_of_points': 4, 'POINT_1': {'x': -400....\n      {'Touched': 1, 'type_of_spectrum': 1, 'minimum...\n      {'Touched': 1, 'Surface_elevation': 0, 'Water_...\n      {'Touched': 1, 'Wind_friction_speed': 0, 'Roug...\n      {'Touched': 1, 'separation_of_wind_sea_and_swe...\n    \n    \n      4\n      1\n      1\n      Spectrum in a point\n      spectrum_x20km_y20km.dfsu\n      4\n      0\n      2\n      UTM-32\n      0\n      ||\n      ...\n      450\n      10\n      1\n      {'name': 'POINT_1', 'x': 38000.0, 'y': 20000.0}\n      {'npoints': 3, 'x_first': 0.0, 'y_first': 0.0,...\n      {'number_of_points': 4, 'POINT_1': {'x': -400....\n      {'Touched': 1, 'type_of_spectrum': 1, 'minimum...\n      {'Touched': 1, 'Surface_elevation': 0, 'Water_...\n      {'Touched': 1, 'Wind_friction_speed': 0, 'Roug...\n      {'Touched': 1, 'separation_of_wind_sea_and_swe...\n    \n  \n\n4 rows × 24 columns\n\n\n\n\n\n\nThe PfsSection object can be modified. Existing values can be changes, new key-value pairs can be added, subsections can added or removed.\n\npfs.SW.SPECTRAL.number_of_directions = 32\n\n\npfs.SW.SPECTRAL\n\nTouched: 1\ntype_of_frequency_discretization: 2\nnumber_of_frequencies: 25\nminimum_frequency: 0.055\nfrequency_interval: 0.02\nfrequency_factor: 1.1\ntype_of_directional_discretization: 1\nnumber_of_directions: 32\nminimum_direction: 0.0\nmaximum_direction: 0.0\nseparation_of_wind_sea_and_swell: 0\nthreshold_frequency: 0.125\nmaximum_threshold_frequency: 0.5959088268863615\n\n\n\n\n\npfs.SW.SPECTRAL[\"new_keyword\"] = \"new_value\"\n\n\npfs.SW.SPECTRAL\n\nTouched: 1\ntype_of_frequency_discretization: 2\nnumber_of_frequencies: 25\nminimum_frequency: 0.055\nfrequency_interval: 0.02\nfrequency_factor: 1.1\ntype_of_directional_discretization: 1\nnumber_of_directions: 32\nminimum_direction: 0.0\nmaximum_direction: 0.0\nseparation_of_wind_sea_and_swell: 0\nthreshold_frequency: 0.125\nmaximum_threshold_frequency: 0.5959088268863615\nnew_keyword: new_value\n\n\n\n\n\nLet’s create an additional output, by copying OUTPUT_4 and modifying some parameters.\n\npfs.SW.OUTPUTS.number_of_outputs += 1\n\n\nnew_output = pfs.SW.OUTPUTS.OUTPUT_4.copy()\n\n\nnew_output.file_name = 'spectrum_x10km_y40km.dfsu'\nnew_output.POINT_1.x = 10000\nnew_output.POINT_1.y = 40000\n\n\npfs.SW.OUTPUTS[\"OUTPUT_5\"] = new_output\n\n\npfs.SW.OUTPUTS.keys()\n\ndict_keys(['Touched', 'MzSEPfsListItemCount', 'number_of_outputs', 'OUTPUT_1', 'OUTPUT_2', 'OUTPUT_3', 'OUTPUT_4', 'OUTPUT_5'])\n\n\n\n\n\n\nThe Pfs object can be written to pfs file, but can also be exported to a dictionary (which in turn can be written to a yaml or json file).\n\npfs.write(\"lake_modified.pfs\")\n\n\npfs.to_dict()\n\n{'FemEngineSW': {'DOMAIN': {'Touched': 1,\n   'discretization': 2,\n   'number_of_dimensions': 2,\n   'number_of_meshes': 1,\n   'file_name': '|.\\\\Lake_Mesh.mesh|',\n   'type_of_reordering': 1,\n   'number_of_domains': 16,\n   'coordinate_type': 'UTM-32',\n   'minimum_depth': 0.0,\n   'datum_depth': 0.0,\n   'vertical_mesh_type_overall': 1,\n   'number_of_layers': 11,\n   'z_sigma': 0.0,\n   'vertical_mesh_type': 1,\n   'layer_thickness': [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.0],\n   'sigma_c': 0.0,\n   'theta': 2.0,\n   'b': 0.0,\n   'number_of_layers_zlevel': 10,\n   'vertical_mesh_type_zlevel': 1,\n   'constant_layer_thickness_zlevel': 0.0,\n   'variable_layer_thickness_zlevel': [0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0],\n   'type_of_bathymetry_adjustment': 1,\n   'minimum_layer_thickness_zlevel': 0.0,\n   'type_of_mesh': 0,\n   'type_of_gauss': 3,\n   'BOUNDARY_NAMES': {'Touched': 0, 'MzSEPfsListItemCount': 0}},\n  'TIME': {'Touched': 1,\n   'start_time': datetime.datetime(2002, 1, 1, 0, 0),\n   'time_step_interval': 120.0,\n   'number_of_time_steps': 450},\n  'MODULE_SELECTION': {'Touched': 0,\n   'mode_of_hydrodynamic_module': 0,\n   'hydrodynamic_features': 1,\n   'fluid_property': 1,\n   'mode_of_spectral_wave_module': 2,\n   'mode_of_transport_module': 0,\n   'mode_of_mud_transport_module': 0,\n   'mode_of_eco_lab_module': 0,\n   'mode_of_sand_transport_module': 0,\n   'mode_of_particle_tracking_module': 0,\n   'mode_of_oil_spill_module': 0,\n   'mode_of_shoreline_module': 0},\n  'SPECTRAL_WAVE_MODULE': {'mode': 2,\n   'SPACE': {'number_of_mesh_geometry': 1},\n   'EQUATION': {'Touched': 1,\n    'formulation': 2,\n    'time_formulation': 2,\n    'JONSWAP_factor_1': 0.92,\n    'JONSWAP_factor_2': 0.83},\n   'TIME': {'Touched': 0,\n    'start_time_step': 0,\n    'time_step_factor': 1,\n    'time_step_factor_AD': 1},\n   'SPECTRAL': {'Touched': 1,\n    'type_of_frequency_discretization': 2,\n    'number_of_frequencies': 25,\n    'minimum_frequency': 0.055,\n    'frequency_interval': 0.02,\n    'frequency_factor': 1.1,\n    'type_of_directional_discretization': 1,\n    'number_of_directions': 32,\n    'minimum_direction': 0.0,\n    'maximum_direction': 0.0,\n    'separation_of_wind_sea_and_swell': 0,\n    'threshold_frequency': 0.125,\n    'maximum_threshold_frequency': 0.5959088268863615,\n    'new_keyword': 'new_value'},\n   'SOLUTION_TECHNIQUE': {'Touched': 1,\n    'error_level': 0,\n    'maximum_number_of_errors': 200,\n    'minimum_period': 0.1,\n    'maximum_period': 25.0,\n    'initial_period': 8.0,\n    'scheme_of_space_discretization_geographical': 1,\n    'scheme_of_space_discretization_direction': 1,\n    'scheme_of_space_discretization_frequency': 1,\n    'method': 2,\n    'number_of_iterations': 10,\n    'tolerance1': 0.0001,\n    'tolerance2': 0.001,\n    'relaxation_factor': 0.1,\n    'number_of_levels_in_transport_calc': 32,\n    'number_of_steps_in_source_calc': 1,\n    'maximum_CFL_number': 1.0,\n    'dt_min': 0.01,\n    'dt_max': 120.0,\n    'type_overall': 0,\n    'file_name_overall': '|.\\\\convergence_overall.dfs0|',\n    'input_format': 1,\n    'coordinate_type': '',\n    'input_file_name': '||',\n    'number_of_points': 0,\n    'type_domain': 0,\n    'file_name_domain': '|.\\\\convergence_domain.dfsu|',\n    'output_frequency': 5},\n   'DEPTH': {'Touched': 1,\n    'type': 0,\n    'minimum_depth': 0.01,\n    'format': 0,\n    'soft_time_interval': 0.0,\n    'constant_level': 0.0,\n    'file_name': '||',\n    'item_number': 1,\n    'item_name': ''},\n   'CURRENT': {'Touched': 1,\n    'type': 0,\n    'type_blocking': 1,\n    'factor_blocking': 0.1,\n    'format': 0,\n    'soft_time_interval': 0.0,\n    'constant_x_velocity': 0.0,\n    'constant_y_velocity': 0.0,\n    'file_name': '||',\n    'item_number_for_x_velocity': 0,\n    'item_number_for_y_velocity': 0,\n    'item_name_for_x_velocity': '',\n    'item_name_for_y_velocity': ''},\n   'WIND': {'Touched': 1,\n    'type': 1,\n    'format': 1,\n    'constant_speed': 15.0,\n    'constant_direction': 270.0,\n    'file_name': '|.\\\\Wind.dfs0|',\n    'item_number_for_speed': 1,\n    'item_number_for_direction': 2,\n    'item_name_for_speed': 'Speed',\n    'item_name_for_direction': 'Direction',\n    'soft_time_interval': 0.0,\n    'formula': 1,\n    'type_of_drag': 1,\n    'linear_growth_coefficient': 0.0015,\n    'type_of_air_sea_interaction': 1,\n    'background_Charnock_parameter': 0.01,\n    'Charnock_parameter': 0.01,\n    'alpha_drag': 0.00063,\n    'beta_drag': 6.6e-05},\n   'ICE': {'Touched': 1,\n    'type': 0,\n    'format': 3,\n    'c_cut_off': 0.33,\n    'file_name': '||',\n    'item_number': 1,\n    'item_name': ''},\n   'DIFFRACTION': {'Touched': 1,\n    'type': 0,\n    'minimum_delta': -0.75,\n    'maximum_delta': 3.0,\n    'type_of_smoothing': 1,\n    'smoothing_factor': 1.0,\n    'number_of_smoothing_steps': 1},\n   'TRANSFER': {'Touched': 1, 'type': 1, 'type_triad': 0, 'alpha_EB': 0.25},\n   'WAVE_BREAKING': {'Touched': 1,\n    'type': 0,\n    'type_of_gamma': 1,\n    'alpha': 1.0,\n    'gamma_steepness': 1.0,\n    'type_of_effect_on_frequency': 1,\n    'type_of_roller': 0,\n    'roller_propagation_factor': 1.0,\n    'roller_dissipation_factor': 0.15,\n    'roller_density': 1000.0,\n    'GAMMA': {'Touched': 1,\n     'type': 1,\n     'format': 0,\n     'constant_value': 0.55,\n     'file_name': '||',\n     'item_number': 1,\n     'item_name': '',\n     'type_of_soft_start': 2,\n     'soft_time_interval': 0.0,\n     'reference_value': 0.0,\n     'type_of_time_interpolation': 1}},\n   'BOTTOM_FRICTION': {'Touched': 1,\n    'type': 0,\n    'constant_fc': 0.0,\n    'type_of_effect_on_frequency': 0,\n    'FRICTION_COEFFICIENT': {'Touched': 1,\n     'type': 1,\n     'format': 0,\n     'constant_value': 0.0775,\n     'file_name': '||',\n     'item_number': 1,\n     'item_name': '',\n     'type_of_soft_start': 2,\n     'soft_time_interval': 0.0,\n     'reference_value': 0.0,\n     'type_of_time_interpolation': 1},\n    'FRICTION_FACTOR': {'Touched': 1,\n     'type': 1,\n     'format': 0,\n     'constant_value': 0.0212,\n     'file_name': '||',\n     'item_number': 1,\n     'item_name': '',\n     'type_of_soft_start': 2,\n     'soft_time_interval': 0.0,\n     'reference_value': 0.0,\n     'type_of_time_interpolation': 1},\n    'NIKURADSE_ROUGHNESS': {'Touched': 1,\n     'type': 1,\n     'format': 0,\n     'constant_value': 0.04,\n     'file_name': '||',\n     'item_number': 1,\n     'item_name': '',\n     'type_of_soft_start': 2,\n     'soft_time_interval': 0.0,\n     'reference_value': 0.0,\n     'type_of_time_interpolation': 1},\n    'SAND_GRAIN_SIZE': {'Touched': 1,\n     'type': 1,\n     'format': 0,\n     'constant_value': 0.00025,\n     'file_name': '||',\n     'item_number': 1,\n     'item_name': '',\n     'type_of_soft_start': 2,\n     'soft_time_interval': 0.0,\n     'reference_value': 0.0,\n     'type_of_time_interpolation': 1}},\n   'WHITECAPPING': {'Touched': 1,\n    'type': 1,\n    'type_of_spectrum': 3,\n    'mean_frequency_power': -1,\n    'mean_wave_number_power': -1,\n    'dissipation_cdiss': {'Touched': 1,\n     'type': 1,\n     'format': 0,\n     'constant_value': 4.5,\n     'file_name': '||',\n     'item_number': 1,\n     'item_name': '',\n     'type_of_soft_start': 2,\n     'soft_time_interval': 0.0,\n     'reference_value': 0.0,\n     'type_of_time_interpolation': 1},\n    'dissipation_delta': {'Touched': 1,\n     'type': 1,\n     'format': 0,\n     'constant_value': 0.5,\n     'file_name': '||',\n     'item_number': 1,\n     'item_name': '',\n     'type_of_soft_start': 2,\n     'soft_time_interval': 0.0,\n     'reference_value': 0.0,\n     'type_of_time_interpolation': 1}},\n   'STRUCTURES': {'type': 0,\n    'input_format': 1,\n    'coordinate_type': '',\n    'number_of_structures': 0,\n    'input_file_name': '||',\n    'LINE_STRUCTURES': {'Touched': 1,\n     'MzSEPfsListItemCount': 0,\n     'output_of_link_data': 0,\n     'file_name_section': 'line_section.xyz',\n     'number_of_structures': 0}},\n   'INITIAL_CONDITIONS': {'Touched': 1,\n    'type': 0,\n    'type_additional': 1,\n    'type_of_spectra': 1,\n    'fetch': 40000.0,\n    'max_peak_frequency': 0.4,\n    'max_Phillips_constant': 0.0081,\n    'shape_parameter_sigma_a': 0.07,\n    'shape_parameter_sigma_b': 0.09,\n    'peakednes_parameter_gamma': 3.3,\n    'file_name_m': '||',\n    'item_number_m0': 1,\n    'item_number_m1': 1,\n    'item_name_m0': '',\n    'item_name_m1': '',\n    'file_name_A': '||',\n    'item_number_A': 1,\n    'item_name_A': ''},\n   'BOUNDARY_CONDITIONS': {'Touched': 0,\n    'MzSEPfsListItemCount': 0,\n    'CODE_1': None},\n   'OUTPUTS': {'Touched': 1,\n    'MzSEPfsListItemCount': 4,\n    'number_of_outputs': 5,\n    'OUTPUT_1': {'Touched': 1,\n     'include': 1,\n     'title': 'Wave parameters in domain',\n     'file_name': 'Wave_parameters.dfsu',\n     'type': 1,\n     'format': 2,\n     'flood_and_dry': 2,\n     'coordinate_type': 'UTM-32',\n     'zone': 0,\n     'input_file_name': '||',\n     'input_format': 1,\n     'interpolation_type': 1,\n     'use_end_time': 1,\n     'first_time_step': 0,\n     'last_time_step': 450,\n     'time_step_frequency': 10,\n     'number_of_points': 1,\n     'POINT_1': {'name': 'POINT_1', 'x': 20000.0, 'y': 20000.0},\n     'LINE': {'npoints': 3,\n      'x_first': 0.0,\n      'y_first': 0.0,\n      'x_last': 40000.0,\n      'y_last': 40000.0},\n     'AREA': {'number_of_points': 4,\n      'POINT_1': {'x': -400.0, 'y': -400.0},\n      'POINT_2': {'x': -400.0, 'y': 40400.0},\n      'POINT_3': {'x': 40400.0, 'y': 40400.0},\n      'POINT_4': {'x': 40400.0, 'y': -400.0},\n      'orientation': 0.0,\n      'x_origo': 0.0,\n      'x_ds': 2105.263157894737,\n      'x_npoints': 20,\n      'y_origo': 0.0,\n      'y_ds': 2105.263157894737,\n      'y_npoints': 20,\n      'z_origo': -15.00000000000001,\n      'z_ds': 2.000000000000001,\n      'z_npoints': 10},\n     'INTEGRAL_WAVE_PARAMETERS': {'Touched': 1,\n      'type_of_spectrum': 1,\n      'minimum_frequency': 0.055,\n      'maximum_frequency': 0.5959088268863617,\n      'separation_of_wind_sea_and_swell': 3,\n      'threshold_frequency': 0.125,\n      'maximum_threshold_frequency': 0.125,\n      'hm0_minimum': 0.01,\n      'type_of_h_max': 3,\n      'duration': 10800.0,\n      'distance_above_bed_for_particle_velocity': 0.0,\n      'minimum_direction': 0.0,\n      'maximum_direction': 360.0,\n      'Total_wave_parameters': {'Significant_wave_height': 1,\n       'Maximum_wave_height': 0,\n       'Peak_wave_period': 1,\n       'Wave_period_t01': 0,\n       'Wave_period_t02': 1,\n       'Wave_period_tm10': 0,\n       'Peak_wave_direction': 0,\n       'Mean_wave_direction': 1,\n       'Directional_standard_deviation': 0,\n       'Wave_velocity_components': 1,\n       'Radiation_stresses': 0,\n       'Particle_velocities': 0,\n       'Wave_power': 0},\n      'Wind_sea_parameters': {'Significant_wave_height': 0,\n       'Maximum_wave_height': 0,\n       'Peak_wave_period': 0,\n       'Wave_period_t01': 0,\n       'Wave_period_t02': 0,\n       'Wave_period_tm10': 0,\n       'Peak_wave_direction': 0,\n       'Mean_wave_direction': 0,\n       'Directional_standard_deviation': 0,\n       'Wave_velocity_components': 0,\n       'Radiation_stresses': 0,\n       'Particle_velocities': 0,\n       'Wave_power': 0},\n      'Swell_parameters': {'Significant_wave_height': 0,\n       'Maximum_wave_height': 0,\n       'Peak_wave_period': 0,\n       'Wave_period_t01': 0,\n       'Wave_period_t02': 0,\n       'Wave_period_tm10': 0,\n       'Peak_wave_direction': 0,\n       'Mean_wave_direction': 0,\n       'Directional_standard_deviation': 0,\n       'Wave_velocity_components': 0,\n       'Radiation_stresses': 0,\n       'Particle_velocities': 0,\n       'Wave_power': 0}},\n     'INPUT_PARAMETERS': {'Touched': 1,\n      'Surface_elevation': 0,\n      'Water_depth': 0,\n      'Current_velocity_components': 0,\n      'Wind_speed': 0,\n      'Wind_direction': 0,\n      'Ice_concentration': 0},\n     'MODEL_PARAMETERS': {'Touched': 1,\n      'Wind_friction_speed': 0,\n      'Roughness_length': 0,\n      'Drag_coefficient': 0,\n      'Charnock_constant': 0,\n      'Friction_coefficient': 0,\n      'Breaking_parameter_gamma': 0,\n      'Courant_number': 1,\n      'Time_step_factor': 1,\n      'Convergence_angle': 0,\n      'Length': 0,\n      'Area': 0,\n      'Threshold_period': 0,\n      'Roller_area': 0,\n      'Roller_dissipation': 0,\n      'Breaking_index': 0},\n     'SPECTRAL_PARAMETERS': {'Touched': 1,\n      'separation_of_wind_sea_and_swell': 3.0,\n      'threshold_frequency': 0.125,\n      'maximum_threshold_frequency': 0.125,\n      'wave_energy': 1,\n      'wave_action': 0,\n      'zeroth_moment_of_wave_action': 0,\n      'first_moment_of_wave_action': 0,\n      'wave_energy_wind_sea': 0,\n      'wave_energy_swell': 0}},\n    'OUTPUT_2': {'Touched': 1,\n     'include': 0,\n     'title': 'Wave parameters along line',\n     'file_name': 'Wave_line.dfs1',\n     'type': 1,\n     'format': 1,\n     'flood_and_dry': 2,\n     'coordinate_type': 'UTM-32',\n     'zone': 0,\n     'input_file_name': '||',\n     'input_format': 1,\n     'interpolation_type': 2,\n     'use_end_time': 1,\n     'first_time_step': 0,\n     'last_time_step': 450,\n     'time_step_frequency': 10,\n     'number_of_points': 1,\n     'POINT_1': {'name': 'POINT_1', 'x': 20000.0, 'y': 20000.0},\n     'LINE': {'npoints': 41,\n      'x_first': 0.0,\n      'y_first': 20000.0,\n      'x_last': 40000.0,\n      'y_last': 20000.0},\n     'AREA': {'number_of_points': 4,\n      'POINT_1': {'x': -400.0, 'y': -400.0},\n      'POINT_2': {'x': -400.0, 'y': 40400.0},\n      'POINT_3': {'x': 40400.0, 'y': 40400.0},\n      'POINT_4': {'x': 40400.0, 'y': -400.0},\n      'orientation': 0.0,\n      'x_origo': 0.0,\n      'x_ds': 2105.263157894737,\n      'x_npoints': 20,\n      'y_origo': 0.0,\n      'y_ds': 2105.263157894737,\n      'y_npoints': 20,\n      'z_origo': -15.00000000000001,\n      'z_ds': 2.000000000000001,\n      'z_npoints': 10},\n     'INTEGRAL_WAVE_PARAMETERS': {'Touched': 1,\n      'type_of_spectrum': 1,\n      'minimum_frequency': 0.055,\n      'maximum_frequency': 0.5959088268863617,\n      'separation_of_wind_sea_and_swell': 3,\n      'threshold_frequency': 0.125,\n      'maximum_threshold_frequency': 0.125,\n      'hm0_minimum': 0.01,\n      'type_of_h_max': 3,\n      'duration': 10800.0,\n      'distance_above_bed_for_particle_velocity': 0.0,\n      'minimum_direction': 0.0,\n      'maximum_direction': 360.0,\n      'Total_wave_parameters': {'Significant_wave_height': 1,\n       'Maximum_wave_height': 0,\n       'Peak_wave_period': 1,\n       'Wave_period_t01': 0,\n       'Wave_period_t02': 1,\n       'Wave_period_tm10': 0,\n       'Peak_wave_direction': 0,\n       'Mean_wave_direction': 1,\n       'Directional_standard_deviation': 0,\n       'Wave_velocity_components': 0,\n       'Radiation_stresses': 0,\n       'Particle_velocities': 0,\n       'Wave_power': 0},\n      'Wind_sea_parameters': {'Significant_wave_height': 0,\n       'Maximum_wave_height': 0,\n       'Peak_wave_period': 0,\n       'Wave_period_t01': 0,\n       'Wave_period_t02': 0,\n       'Wave_period_tm10': 0,\n       'Peak_wave_direction': 0,\n       'Mean_wave_direction': 0,\n       'Directional_standard_deviation': 0,\n       'Wave_velocity_components': 0,\n       'Radiation_stresses': 0,\n       'Particle_velocities': 0,\n       'Wave_power': 0},\n      'Swell_parameters': {'Significant_wave_height': 0,\n       'Maximum_wave_height': 0,\n       'Peak_wave_period': 0,\n       'Wave_period_t01': 0,\n       'Wave_period_t02': 0,\n       'Wave_period_tm10': 0,\n       'Peak_wave_direction': 0,\n       'Mean_wave_direction': 0,\n       'Directional_standard_deviation': 0,\n       'Wave_velocity_components': 0,\n       'Radiation_stresses': 0,\n       'Particle_velocities': 0,\n       'Wave_power': 0}},\n     'INPUT_PARAMETERS': {'Touched': 1,\n      'Surface_elevation': 0,\n      'Water_depth': 0,\n      'Current_velocity_components': 0,\n      'Wind_speed': 0,\n      'Wind_direction': 0,\n      'Ice_concentration': 0},\n     'MODEL_PARAMETERS': {'Touched': 1,\n      'Wind_friction_speed': 0,\n      'Roughness_length': 0,\n      'Drag_coefficient': 0,\n      'Charnock_constant': 0,\n      'Friction_coefficient': 0,\n      'Breaking_parameter_gamma': 0,\n      'Courant_number': 0,\n      'Time_step_factor': 0,\n      'Convergence_angle': 0,\n      'Length': 0,\n      'Area': 0,\n      'Threshold_period': 0,\n      'Roller_area': 0,\n      'Roller_dissipation': 0,\n      'Breaking_index': 0},\n     'SPECTRAL_PARAMETERS': {'Touched': 1,\n      'separation_of_wind_sea_and_swell': 3.0,\n      'threshold_frequency': 0.125,\n      'maximum_threshold_frequency': 0.125,\n      'wave_energy': 1,\n      'wave_action': 0,\n      'zeroth_moment_of_wave_action': 0,\n      'first_moment_of_wave_action': 0,\n      'wave_energy_wind_sea': 0,\n      'wave_energy_swell': 0}},\n    'OUTPUT_3': {'Touched': 1,\n     'include': 1,\n     'title': 'Wave parameters  in a point',\n     'file_name': 'Waves_x20km_y20km.dfs0',\n     'type': 1,\n     'format': 0,\n     'flood_and_dry': 2,\n     'coordinate_type': 'UTM-32',\n     'zone': 0,\n     'input_file_name': '||',\n     'input_format': 1,\n     'interpolation_type': 2,\n     'use_end_time': 1,\n     'first_time_step': 0,\n     'last_time_step': 450,\n     'time_step_frequency': 1,\n     'number_of_points': 1,\n     'POINT_1': {'name': 'POINT_1', 'x': 38000.0, 'y': 20000.0},\n     'LINE': {'npoints': 3,\n      'x_first': 0.0,\n      'y_first': 0.0,\n      'x_last': 40000.0,\n      'y_last': 40000.0},\n     'AREA': {'number_of_points': 4,\n      'POINT_1': {'x': -400.0, 'y': -400.0},\n      'POINT_2': {'x': -400.0, 'y': 40400.0},\n      'POINT_3': {'x': 40400.0, 'y': 40400.0},\n      'POINT_4': {'x': 40400.0, 'y': -400.0},\n      'orientation': 0.0,\n      'x_origo': 0.0,\n      'x_ds': 2105.263157894737,\n      'x_npoints': 20,\n      'y_origo': 0.0,\n      'y_ds': 2105.263157894737,\n      'y_npoints': 20,\n      'z_origo': -15.00000000000001,\n      'z_ds': 2.000000000000001,\n      'z_npoints': 10},\n     'INTEGRAL_WAVE_PARAMETERS': {'Touched': 1,\n      'type_of_spectrum': 1,\n      'minimum_frequency': 0.055,\n      'maximum_frequency': 0.5959088268863617,\n      'separation_of_wind_sea_and_swell': 3,\n      'threshold_frequency': 0.125,\n      'maximum_threshold_frequency': 0.125,\n      'hm0_minimum': 0.01,\n      'type_of_h_max': 3,\n      'duration': 10800.0,\n      'distance_above_bed_for_particle_velocity': 0.0,\n      'minimum_direction': 0.0,\n      'maximum_direction': 360.0,\n      'Total_wave_parameters': {'Significant_wave_height': 1,\n       'Maximum_wave_height': 0,\n       'Peak_wave_period': 1,\n       'Wave_period_t01': 0,\n       'Wave_period_t02': 1,\n       'Wave_period_tm10': 0,\n       'Peak_wave_direction': 0,\n       'Mean_wave_direction': 1,\n       'Directional_standard_deviation': 0,\n       'Wave_velocity_components': 0,\n       'Radiation_stresses': 0,\n       'Particle_velocities': 0,\n       'Wave_power': 0},\n      'Wind_sea_parameters': {'Significant_wave_height': 0,\n       'Maximum_wave_height': 0,\n       'Peak_wave_period': 0,\n       'Wave_period_t01': 0,\n       'Wave_period_t02': 0,\n       'Wave_period_tm10': 0,\n       'Peak_wave_direction': 0,\n       'Mean_wave_direction': 0,\n       'Directional_standard_deviation': 0,\n       'Wave_velocity_components': 0,\n       'Radiation_stresses': 0,\n       'Particle_velocities': 0,\n       'Wave_power': 0},\n      'Swell_parameters': {'Significant_wave_height': 0,\n       'Maximum_wave_height': 0,\n       'Peak_wave_period': 0,\n       'Wave_period_t01': 0,\n       'Wave_period_t02': 0,\n       'Wave_period_tm10': 0,\n       'Peak_wave_direction': 0,\n       'Mean_wave_direction': 0,\n       'Directional_standard_deviation': 0,\n       'Wave_velocity_components': 0,\n       'Radiation_stresses': 0,\n       'Particle_velocities': 0,\n       'Wave_power': 0}},\n     'INPUT_PARAMETERS': {'Touched': 1,\n      'Surface_elevation': 0,\n      'Water_depth': 0,\n      'Current_velocity_components': 0,\n      'Wind_speed': 0,\n      'Wind_direction': 0,\n      'Ice_concentration': 0},\n     'MODEL_PARAMETERS': {'Touched': 1,\n      'Wind_friction_speed': 0,\n      'Roughness_length': 0,\n      'Drag_coefficient': 0,\n      'Charnock_constant': 0,\n      'Friction_coefficient': 0,\n      'Breaking_parameter_gamma': 0,\n      'Courant_number': 0,\n      'Time_step_factor': 0,\n      'Convergence_angle': 0,\n      'Length': 0,\n      'Area': 0,\n      'Threshold_period': 0,\n      'Roller_area': 0,\n      'Roller_dissipation': 0,\n      'Breaking_index': 0},\n     'SPECTRAL_PARAMETERS': {'Touched': 1,\n      'separation_of_wind_sea_and_swell': 3.0,\n      'threshold_frequency': 0.125,\n      'maximum_threshold_frequency': 0.125,\n      'wave_energy': 1,\n      'wave_action': 0,\n      'zeroth_moment_of_wave_action': 0,\n      'first_moment_of_wave_action': 0,\n      'wave_energy_wind_sea': 0,\n      'wave_energy_swell': 0}},\n    'OUTPUT_4': {'Touched': 1,\n     'include': 1,\n     'title': 'Spectrum in a point',\n     'file_name': 'spectrum_x20km_y20km.dfsu',\n     'type': 4,\n     'format': 0,\n     'flood_and_dry': 2,\n     'coordinate_type': 'UTM-32',\n     'zone': 0,\n     'input_file_name': '||',\n     'input_format': 1,\n     'interpolation_type': 2,\n     'use_end_time': 1,\n     'first_time_step': 0,\n     'last_time_step': 450,\n     'time_step_frequency': 10,\n     'number_of_points': 1,\n     'POINT_1': {'name': 'POINT_1', 'x': 38000.0, 'y': 20000.0},\n     'LINE': {'npoints': 3,\n      'x_first': 0.0,\n      'y_first': 0.0,\n      'x_last': 40000.0,\n      'y_last': 40000.0},\n     'AREA': {'number_of_points': 4,\n      'POINT_1': {'x': -400.0, 'y': -400.0},\n      'POINT_2': {'x': -400.0, 'y': 40400.0},\n      'POINT_3': {'x': 40400.0, 'y': 40400.0},\n      'POINT_4': {'x': 40400.0, 'y': -400.0},\n      'orientation': 0.0,\n      'x_origo': 0.0,\n      'x_ds': 2105.263157894737,\n      'x_npoints': 20,\n      'y_origo': 0.0,\n      'y_ds': 2105.263157894737,\n      'y_npoints': 20,\n      'z_origo': -15.00000000000001,\n      'z_ds': 2.000000000000001,\n      'z_npoints': 10},\n     'INTEGRAL_WAVE_PARAMETERS': {'Touched': 1,\n      'type_of_spectrum': 1,\n      'minimum_frequency': 0.054321,\n      'maximum_frequency': 0.0987654321,\n      'separation_of_wind_sea_and_swell': 3,\n      'threshold_frequency': 0.125,\n      'maximum_threshold_frequency': 0.125,\n      'hm0_minimum': 0.01,\n      'type_of_h_max': 3,\n      'duration': 10800.0,\n      'distance_above_bed_for_particle_velocity': 0.0,\n      'minimum_direction': 0.0,\n      'maximum_direction': 360.0,\n      'Total_wave_parameters': {'Significant_wave_height': 1,\n       'Maximum_wave_height': 1,\n       'Peak_wave_period': 0,\n       'Wave_period_t01': 0,\n       'Wave_period_t02': 1,\n       'Wave_period_tm10': 0,\n       'Peak_wave_direction': 0,\n       'Mean_wave_direction': 1,\n       'Directional_standard_deviation': 0,\n       'Wave_velocity_components': 1,\n       'Radiation_stresses': 0,\n       'Particle_velocities': 0,\n       'Wave_power': 0},\n      'Wind_sea_parameters': {'Significant_wave_height': 0,\n       'Maximum_wave_height': 0,\n       'Peak_wave_period': 0,\n       'Wave_period_t01': 0,\n       'Wave_period_t02': 0,\n       'Wave_period_tm10': 0,\n       'Peak_wave_direction': 0,\n       'Mean_wave_direction': 0,\n       'Directional_standard_deviation': 0,\n       'Wave_velocity_components': 0,\n       'Radiation_stresses': 0,\n       'Particle_velocities': 0,\n       'Wave_power': 0},\n      'Swell_parameters': {'Significant_wave_height': 0,\n       'Maximum_wave_height': 0,\n       'Peak_wave_period': 0,\n       'Wave_period_t01': 0,\n       'Wave_period_t02': 0,\n       'Wave_period_tm10': 0,\n       'Peak_wave_direction': 0,\n       'Mean_wave_direction': 0,\n       'Directional_standard_deviation': 0,\n       'Wave_velocity_components': 0,\n       'Radiation_stresses': 0,\n       'Particle_velocities': 0,\n       'Wave_power': 0}},\n     'INPUT_PARAMETERS': {'Touched': 1,\n      'Surface_elevation': 0,\n      'Water_depth': 0,\n      'Current_velocity_components': 0,\n      'Wind_speed': 0,\n      'Wind_direction': 0,\n      'Ice_concentration': 0},\n     'MODEL_PARAMETERS': {'Touched': 1,\n      'Wind_friction_speed': 0,\n      'Roughness_length': 0,\n      'Drag_coefficient': 0,\n      'Charnock_constant': 0,\n      'Friction_coefficient': 0,\n      'Breaking_parameter_gamma': 0,\n      'Courant_number': 0,\n      'Time_step_factor': 0,\n      'Convergence_angle': 0,\n      'Length': 0,\n      'Area': 0,\n      'Threshold_period': 0,\n      'Roller_area': 0,\n      'Roller_dissipation': 0,\n      'Breaking_index': 0},\n     'SPECTRAL_PARAMETERS': {'Touched': 1,\n      'separation_of_wind_sea_and_swell': 3.0,\n      'threshold_frequency': 0.125,\n      'maximum_threshold_frequency': 0.125,\n      'wave_energy': 1,\n      'wave_action': 0,\n      'zeroth_moment_of_wave_action': 0,\n      'first_moment_of_wave_action': 0,\n      'wave_energy_wind_sea': 0,\n      'wave_energy_swell': 0}},\n    'OUTPUT_5': {'Touched': 1,\n     'include': 1,\n     'title': 'Spectrum in a point',\n     'file_name': 'spectrum_x10km_y40km.dfsu',\n     'type': 4,\n     'format': 0,\n     'flood_and_dry': 2,\n     'coordinate_type': 'UTM-32',\n     'zone': 0,\n     'input_file_name': '||',\n     'input_format': 1,\n     'interpolation_type': 2,\n     'use_end_time': 1,\n     'first_time_step': 0,\n     'last_time_step': 450,\n     'time_step_frequency': 10,\n     'number_of_points': 1,\n     'POINT_1': {'name': 'POINT_1', 'x': 10000, 'y': 40000},\n     'LINE': {'npoints': 3,\n      'x_first': 0.0,\n      'y_first': 0.0,\n      'x_last': 40000.0,\n      'y_last': 40000.0},\n     'AREA': {'number_of_points': 4,\n      'POINT_1': {'x': -400.0, 'y': -400.0},\n      'POINT_2': {'x': -400.0, 'y': 40400.0},\n      'POINT_3': {'x': 40400.0, 'y': 40400.0},\n      'POINT_4': {'x': 40400.0, 'y': -400.0},\n      'orientation': 0.0,\n      'x_origo': 0.0,\n      'x_ds': 2105.263157894737,\n      'x_npoints': 20,\n      'y_origo': 0.0,\n      'y_ds': 2105.263157894737,\n      'y_npoints': 20,\n      'z_origo': -15.00000000000001,\n      'z_ds': 2.000000000000001,\n      'z_npoints': 10},\n     'INTEGRAL_WAVE_PARAMETERS': {'Touched': 1,\n      'type_of_spectrum': 1,\n      'minimum_frequency': 0.054321,\n      'maximum_frequency': 0.0987654321,\n      'separation_of_wind_sea_and_swell': 3,\n      'threshold_frequency': 0.125,\n      'maximum_threshold_frequency': 0.125,\n      'hm0_minimum': 0.01,\n      'type_of_h_max': 3,\n      'duration': 10800.0,\n      'distance_above_bed_for_particle_velocity': 0.0,\n      'minimum_direction': 0.0,\n      'maximum_direction': 360.0,\n      'Total_wave_parameters': {'Significant_wave_height': 1,\n       'Maximum_wave_height': 1,\n       'Peak_wave_period': 0,\n       'Wave_period_t01': 0,\n       'Wave_period_t02': 1,\n       'Wave_period_tm10': 0,\n       'Peak_wave_direction': 0,\n       'Mean_wave_direction': 1,\n       'Directional_standard_deviation': 0,\n       'Wave_velocity_components': 1,\n       'Radiation_stresses': 0,\n       'Particle_velocities': 0,\n       'Wave_power': 0},\n      'Wind_sea_parameters': {'Significant_wave_height': 0,\n       'Maximum_wave_height': 0,\n       'Peak_wave_period': 0,\n       'Wave_period_t01': 0,\n       'Wave_period_t02': 0,\n       'Wave_period_tm10': 0,\n       'Peak_wave_direction': 0,\n       'Mean_wave_direction': 0,\n       'Directional_standard_deviation': 0,\n       'Wave_velocity_components': 0,\n       'Radiation_stresses': 0,\n       'Particle_velocities': 0,\n       'Wave_power': 0},\n      'Swell_parameters': {'Significant_wave_height': 0,\n       'Maximum_wave_height': 0,\n       'Peak_wave_period': 0,\n       'Wave_period_t01': 0,\n       'Wave_period_t02': 0,\n       'Wave_period_tm10': 0,\n       'Peak_wave_direction': 0,\n       'Mean_wave_direction': 0,\n       'Directional_standard_deviation': 0,\n       'Wave_velocity_components': 0,\n       'Radiation_stresses': 0,\n       'Particle_velocities': 0,\n       'Wave_power': 0}},\n     'INPUT_PARAMETERS': {'Touched': 1,\n      'Surface_elevation': 0,\n      'Water_depth': 0,\n      'Current_velocity_components': 0,\n      'Wind_speed': 0,\n      'Wind_direction': 0,\n      'Ice_concentration': 0},\n     'MODEL_PARAMETERS': {'Touched': 1,\n      'Wind_friction_speed': 0,\n      'Roughness_length': 0,\n      'Drag_coefficient': 0,\n      'Charnock_constant': 0,\n      'Friction_coefficient': 0,\n      'Breaking_parameter_gamma': 0,\n      'Courant_number': 0,\n      'Time_step_factor': 0,\n      'Convergence_angle': 0,\n      'Length': 0,\n      'Area': 0,\n      'Threshold_period': 0,\n      'Roller_area': 0,\n      'Roller_dissipation': 0,\n      'Breaking_index': 0},\n     'SPECTRAL_PARAMETERS': {'Touched': 1,\n      'separation_of_wind_sea_and_swell': 3.0,\n      'threshold_frequency': 0.125,\n      'maximum_threshold_frequency': 0.125,\n      'wave_energy': 1,\n      'wave_action': 0,\n      'zeroth_moment_of_wave_action': 0,\n      'first_moment_of_wave_action': 0,\n      'wave_energy_wind_sea': 0,\n      'wave_energy_swell': 0}}}}}}\n\n\n\n# write to yaml file\nimport yaml\nyaml.dump(pfs.to_dict(), open('lake_modified.yaml', 'w+'))\n\n\n\n\nA PFS file can also be created from a dictionary, like this:\n\nsetup = {\n    \"Name\": \"Extract that\",\n    \"InputFileName\": \"|random.dfs1|\",\n    \"FirstTimeStep\": 0,\n    \"LastTimeStep\": 99,\n    \"X\": 2,\n    \"OutputFileName\": \"|.\\\\out2.dfs0|\",\n}\nt1_t0 = {\"CLSID\": \"t1_t0.dll\", \"TypeName\": \"t1_t0\", \"Setup\": setup}\nt1_t0\n\n{'CLSID': 't1_t0.dll',\n 'TypeName': 't1_t0',\n 'Setup': {'Name': 'Extract that',\n  'InputFileName': '|random.dfs1|',\n  'FirstTimeStep': 0,\n  'LastTimeStep': 99,\n  'X': 2,\n  'OutputFileName': '|.\\\\out2.dfs0|'}}\n\n\n\nsection = mikeio.PfsSection(t1_t0)\nsection\n\nCLSID: t1_t0.dll\nTypeName: t1_t0\nSetup:\n  Name: Extract that\n  InputFileName: '|random.dfs1|'\n  FirstTimeStep: 0\n  LastTimeStep: 99\n  X: 2\n  OutputFileName: '|.\\out2.dfs0|'\n\n\n\npfs = section.to_Pfs(name=\"t1_t0\")\npfs\n\n<mikeio.Pfs>\nt1_t0: CLSID: t1_t0.dllTypeName: t1_t0Setup:  Name: ...\n\n\n\npfs.write(\"extract_point.mzt\")\n\n\n\n\n\nimport os\nos.remove(\"lake_modified.pfs\")\nos.remove('lake_modified.yaml')\nos.remove(\"extract_point.mzt\")"
  },
  {
    "objectID": "notebooks/Dfsu and Mesh - Plotting.html",
    "href": "notebooks/Dfsu and Mesh - Plotting.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "Load dfsu file as mesh\n\nfilename = '../tests/testdata/FakeLake.dfsu'\nmsh = mikeio.Mesh(filename)\nmsh\n\nFlexible Mesh\nnumber of elements: 1011\nnumber of nodes: 798\nprojection: PROJCS[\"UTM-17\",GEOGCS[\"Unused\",DATUM[\"UTM Projections\",SPHEROID[\"WGS 1984\",6378137,298.257223563]],PRIMEM[\"Greenwich\",0],UNIT[\"Degree\",0.0174532925199433]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"False_Easting\",500000],PARAMETER[\"False_Northing\",0],PARAMETER[\"Central_Meridian\",-81],PARAMETER[\"Scale_Factor\",0.9996],PARAMETER[\"Latitude_Of_Origin\",0],UNIT[\"Meter\",1]]\n\n\n\nmsh.plot();\n\n\n\n\n\nmsh.plot.mesh();\n\n\n\n\n\nmsh.plot(vmin=-30);\n\n\n\n\n\nmsh.plot.contour(show_mesh=True, levels=16, cmap='tab20', vmin=-30);\n\n\n\n\n\nmsh.plot(plot_type='contourf', show_mesh=True, levels=6, vmin=-30);\n\n\n\n\n\nmsh.plot(plot_type='shaded', show_mesh=False, vmin=-30);\n\n\n\n\n\nmsh.plot(plot_type='shaded', add_colorbar=False);\n\n\n\n\n\nmsh.plot(plot_type='patch', elements=range(400,600), vmin=-30, figsize=(4,6));\n\n\n\n\n\nfig, ax = plt.subplots(3,2)\n\nmsh.plot(title='patch', ax=ax[0,0]);\n#msh.plot.contourf(title='contourf', show_mesh=False, levels=[-30,-24,-22,-10,-8], ax=ax[0,1]);\nmsh.plot.contourf(title='contourf', levels=5, ax=ax[0,1]);\nmsh.plot(plot_type='shaded', title='shaded', ax=ax[1,0]);\nmsh.plot.contour(title='contour', show_mesh=True, levels=6, vmin=-30, ax=ax[1,1]);\nmsh.plot.mesh(title='mesh_only', ax=ax[2,0]);\nmsh.plot.outline(title='outline_only', ax=ax[2,1]);\n\nplt.tight_layout()\n\n\n\n\n\n\nPlot data from surface layer of 3d dfsu file\n\nfilename = \"../tests/testdata/oresund_sigma_z.dfsu\"\ndfs = mikeio.open(filename)\ndfs\n\nDfsu3DSigmaZ\nnumber of elements: 17118\nnumber of nodes: 12042\nprojection: UTM-33\nnumber of sigma layers: 4\nmax number of z layers: 5\nitems:\n  0:  Temperature <Temperature> (degree Celsius)\n  1:  Salinity <Salinity> (PSU)\ntime: 3 steps with dt=10800.0s\n      1997-09-15 21:00:00 -- 1997-09-16 03:00:00\n\n\n\nda = dfs.read(items=\"Salinity\", layers=\"top\", time=0)[0]\nda\n\n<mikeio.DataArray>\nname: Salinity\ndims: (element:3700)\ntime: 1997-09-15 21:00:00 (time-invariant)\ngeometry: Dfsu2D (3700 elements, 2090 nodes)\nvalues: [22.16, 21.16, ..., 21.27]\n\n\n\nda.plot(cmap='plasma');\n\n\n\n\n\nda.plot(add_colorbar=False);\n\n\n\n\n\nax = da.plot.contour(show_mesh=True, cmap='tab20', levels=[11,13,15,17,18,19,20,20.5])\nax.set_ylim(6135000,6160000);\n\n\n\n\n\n\nplot data from a z-layer\n\nda = dfs.read(items=\"Salinity\", layers=3, time=0)[0]\nda\n\n<mikeio.DataArray>\nname: Salinity\ndims: (element:528)\ntime: 1997-09-15 21:00:00 (time-invariant)\ngeometry: Dfsu2D (528 elements, 378 nodes)\nvalues: [20.81, 22.55, ..., 22.45]\n\n\n\nax = da.plot(cmap='plasma');\ndfs.geometry.plot.outline(ax=ax, title=None);"
  },
  {
    "objectID": "notebooks/Mesh.html",
    "href": "notebooks/Mesh.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "read mesh file\nplot mesh\nconvert to shapely\ncheck if point is inside or outside mesh\nsubset mesh, plot subset\nchange z values\nchange boundary codes\n\n\nimport matplotlib.pyplot as plt\nfrom matplotlib_inline.backend_inline import set_matplotlib_formats\nset_matplotlib_formats('png')\nplt.rcParams[\"figure.figsize\"] = (6,6)\n\nimport mikeio\n\n\nmeshfilename = r\"../tests/testdata/odense_rough.mesh\"\nmsh = mikeio.Mesh(meshfilename)\nmsh\n\nFlexible Mesh\nNumber of elements: 654\nNumber of nodes: 399\nProjection: UTM-33\n\n\n\nmsh.plot()\nmsh.plot.boundary_nodes(boundary_names=['Land','Open boundary']);"
  },
  {
    "objectID": "notebooks/Mesh.html#mesh-class-can-also-check-if-a-mesh-contains-points",
    "href": "notebooks/Mesh.html#mesh-class-can-also-check-if-a-mesh-contains-points",
    "title": "mikeio-examples",
    "section": "Mesh class can also check if a mesh contains points",
    "text": "Mesh class can also check if a mesh contains points\n\np1p2 = [[216000, 6162000], [220000, 6156000]]\nmsh.contains(p1p2)\n\narray([ True, False])\n\n\n\nax = msh.plot()\nax.scatter(p1.x, p1.y, marker=\"*\", s=200, c=\"red\", label=\"inside\")\nax.scatter(p2.x, p2.y, marker=\"+\", s=200, c=\"green\", label=\"outside\")\nax.legend();"
  },
  {
    "objectID": "notebooks/Dfs2 - Boundary.html",
    "href": "notebooks/Dfs2 - Boundary.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "Clean up\n\nimport os\nos.remove(\"uv_combined.dfs2\")"
  },
  {
    "objectID": "notebooks/Dfs2 - Various types.html",
    "href": "notebooks/Dfs2 - Various types.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "This notebook examines various Dfs2 types:\n\nHorizontal\n\nUTM (utm_not_rotated_neurope_temp.dfs2)\nLong/Lat (europe_wind_long_lat.dfs2)\nLong/Lat global (global_long_lat_pacific_view_temperature_delta.dfs2)\nLocal coordinates (M3WFM_sponge_local_coordinates.dfs2)\n\nRotated\n\nUTM (BW_Ronne_Layout1998_rotated.dfs2)\n\n\nVertical (hd_vertical_slice.dfs2)\nSpectral\n\nLinear f-axis (dir_wave_analysis_spectra.dfs2)\nLogarithmic f-axis (pt_spectra.dfs2)\n\n\nFor each of these types, it’s possible to :\n\nplot\nisel\nsel (point, line or area)\nread and write without changing header (origo and rotation)\n\n\nimport mikeio\n\n\n\n\n\n\nfn = \"../tests/testdata/utm_not_rotated_neurope_temp.dfs2\"\ndfs = mikeio.open(fn)\nda = dfs.read()[0]\nda\n\n<mikeio.DataArray>\nname: Temperature\ndims: (time:2, y:104, x:119)\ntime: 2022-03-01 00:00:00 - 2022-03-01 12:00:00 (2 records)\ngeometry: Grid2D (ny=104, nx=119)\n\n\n\nda.geometry\n\n<mikeio.Grid2D>\nx: [-2.778e+05, -2.611e+05, ..., 1.689e+06] (nx=119, dx=1.667e+04)\ny: [5.667e+06, 5.684e+06, ..., 7.384e+06] (ny=104, dy=1.667e+04)\nprojection: UTM-32\n\n\n\nda.plot();\n\n\n\n\n\n\n\n\nfn = \"../tests/testdata/europe_wind_long_lat.dfs2\"\nda = mikeio.read(fn)[1]\nda\n\n<mikeio.DataArray>\nname: Wind x-comp (10m)\ndims: (time:1, y:101, x:221)\ntime: 2012-01-01 00:00:00 (time-invariant)\ngeometry: Grid2D (ny=101, nx=221)\n\n\n\nda.geometry\n\n<mikeio.Grid2D>\nx: [-15, -14.75, ..., 40] (nx=221, dx=0.25)\ny: [30, 30.25, ..., 55] (ny=101, dy=0.25)\nprojection: LONG/LAT\n\n\n\nda.plot();\n\n\n\n\n\n\n\n\nfn = \"../tests/testdata/global_long_lat_pacific_view_temperature_delta.dfs2\"\nda = mikeio.read(fn)[0]\nda\n\n<mikeio.DataArray>\nname: air_temperature_anomaly\ndims: (time:12, y:73, x:96)\ntime: 2089-01-16 00:00:00 - 2089-12-16 00:00:00 (12 non-equidistant records)\ngeometry: Grid2D (ny=73, nx=96)\n\n\n\nda.geometry\n\n<mikeio.Grid2D>\nx: [0, 3.75, ..., 356.2] (nx=96, dx=3.75)\ny: [-90, -87.5, ..., 90] (ny=73, dy=2.5)\nprojection: LONG/LAT\n\n\n\nda.plot();\n\n\n\n\n\nda.sel(area=[110,-50,160,-10]).plot();\n\n\n\n\n\n\n\n\nfn = \"../tests/testdata/M3WFM_sponge_local_coordinates.dfs2\"\nda = mikeio.read(fn)[0]\nda\n\n<mikeio.DataArray>\nname: z (m)\ndims: (time:1, y:62, x:362)\ntime: 1990-01-01 12:00:00 (time-invariant)\ngeometry: Grid2D (ny=62, nx=362)\n\n\n\nda.plot();\n\n\n\n\n\nda.sel(y=3).plot();\n\n\n\n\n\n\n\n\n\nfn = \"../tests/testdata/BW_Ronne_Layout1998_rotated.dfs2\"\nda = mikeio.read(fn)[0]\nda\n\n<mikeio.DataArray>\nname: Bathymetry\ndims: (time:1, y:172, x:263)\ntime: 1990-01-01 12:00:00 (time-invariant)\ngeometry: Grid2D (ny=172, nx=263)\n\n\n\nda.geometry\n\n<mikeio.Grid2D>\nx: [0, 5, ..., 1310] (nx=263, dx=5)\ny: [0, 5, ..., 855] (ny=172, dy=5)\norigin: (4.797e+05, 6.105e+06), orientation: -22.239\nprojection: PROJCS[\"UTM-33\",GEOGCS[\"Unused\",DATUM[\"UTM Projections\",SPHEROID[\"WGS 1984\",6378137,298.257223563]],PRIMEM[\"Greenwich\",0],UNIT[\"Degree\",0.0174532925199433]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"False_Easting\",500000],PARAMETER[\"False_Northing\",0],PARAMETER[\"Central_Meridian\",15],PARAMETER[\"Scale_Factor\",0.9996],PARAMETER[\"Latitude_Of_Origin\",0],UNIT[\"Meter\",1]]\n\n\n\nda.plot();\n\n\n\n\n\n\n\n\nfn = \"../tests/testdata/hd_vertical_slice.dfs2\"\nda = mikeio.read(fn)[0]\nda\n\n<mikeio.DataArray>\nname: U velocity\ndims: (time:13, y:76, x:41)\ntime: 2022-04-23 00:00:00 - 2022-04-23 12:00:00 (13 records)\ngeometry: Grid2D (ny=76, nx=41)\n\n\n\nda.geometry\n\n<mikeio.Grid2D>\nx: [0, 0.0193, ..., 0.7722] (nx=41, dx=0.0193)\ny: [0, 1, ..., 75] (ny=76, dy=1)\nprojection: NON-UTM\n\n\n\nda.plot();\n\n\n\n\n\nda.isel(y=slice(45,None)).plot();\n\n\n\n\n\n\n\n\n\n\nfn = \"../tests/testdata/dir_wave_analysis_spectra.dfs2\"\ndfs = mikeio.open(fn) #, type=\"spectral\")\nda = dfs.read()[0]\nda\n\n<mikeio.DataArray>\nname: Directional spectrum [1]\ndims: (time:1, y:37, x:128)\ntime: 1970-01-01 00:00:00 (time-invariant)\ngeometry: Grid2D (ny=37, nx=128)\n\n\n\nda.geometry\n\n<mikeio.Grid2D>\nx: [0.003906, 0.007812, ..., 0.5] (nx=128, dx=0.003906)\ny: [0, 10, ..., 360] (ny=37, dy=10)\nprojection: NON-UTM\n\n\n\nda.geometry.is_spectral = True\nda.plot();\n\n\n\n\n\n\n\n\nfn = \"../tests/testdata/pt_spectra.dfs2\"\ndfs = mikeio.open(fn, type=\"spectral\")\nda = dfs.read()[0]\nda\n\n<mikeio.DataArray>\nname: Point 1: Energy density\ndims: (time:31, y:16, x:25)\ntime: 2017-10-27 00:00:00 - 2017-10-27 05:00:00 (31 records)\ngeometry: Grid2D (ny=16, nx=25)\n\n\n\nda.geometry.is_spectral\n\nTrue\n\n\n\nda.geometry.x   # logarithmic frequency axis\n\narray([0.055     , 0.0605    , 0.06655   , 0.073205  , 0.08052551,\n       0.08857806, 0.09743587, 0.10717946, 0.1178974 , 0.12968715,\n       0.14265587, 0.15692146, 0.1726136 , 0.18987497, 0.20886247,\n       0.22974872, 0.2527236 , 0.27799597, 0.30579557, 0.33637513,\n       0.37001266, 0.40701393, 0.44771533, 0.49248688, 0.54173558])\n\n\n\nda.geometry\n\n<mikeio.Grid2D> (spectral)\nx: [0.055, 0.0605, ..., 0.5417] (nx=25, dx=1.1)\ny: [0, 22.5, ..., 337.5] (ny=16, dy=22.5)\nprojection: LONG/LAT\n\n\n\nda.plot();"
  },
  {
    "objectID": "notebooks/Dfsu - Spectral data other formats.html",
    "href": "notebooks/Dfsu - Spectral data other formats.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "import matplotlib.pyplot as plt\nimport mikeio\n\n\n\nMIKE 21 SW can be run with dicretized directions only in a directional sector. The reading and plotting of such spectra are also supported in MIKE IO.\n\nfn = \"../tests/testdata/MIKE21SW_dir_sector_area_spectra.dfsu\"\ndfs = mikeio.open(fn)\ndfs\n\nDfsuSpectral2D\nnumber of elements: 40\nnumber of nodes: 33\nnumber of directions: 19\nnumber of frequencies: 25\nprojection: LONG/LAT\nitems:\n  0:  Energy density <Wave energy density> (meter pow 2 sec per deg)\ntime: 3 steps with dt=9000.0s\n      2017-10-27 00:00:00 -- 2017-10-27 05:00:00\n\n\n\ndfs.is_spectral\n\nTrue\n\n\n\nda = dfs.read(time=0)[\"Energy density\"]\nda\n\n<mikeio.DataArray>\nname: Energy density\ndims: (element:40, direction:19, frequency:25)\ntime: 2017-10-27 00:00:00 (time-invariant)\ngeometry: DfsuSpectral2D (40 elements, 33 nodes)\n\n\n\nda.plot();\n\n\n\n\n\nda_pt = da.isel(element=0)\nda_pt\n\n<mikeio.DataArray>\nname: Energy density\ndims: (direction:19, frequency:25)\ntime: 2017-10-27 00:00:00 (time-invariant)\ngeometry: Point Spectrum Geometry(frequency:25, direction:19, x:2.58616, y:52.13755)\n\n\n\nda_pt.plot(rmax=10, vmin=0);\n\n\n\n\n\n\n\nFrequency spectra have 0 directions. They can be of type point, line and area.\n\n\n\nfn = \"../tests/testdata/pt_freq_spectra.dfsu\"\n\n\nda = mikeio.read(fn)[0]\nda\n\n<mikeio.DataArray>\nname: Point 1: Directional integrated energy d\ndims: (time:31, frequency:25)\ntime: 2017-10-27 00:00:00 - 2017-10-27 05:00:00 (31 records)\ngeometry: Point Spectrum Geometry(frequency:25, direction:0)\n\n\n\nda.sel(time=\"2017-10-27 02:00\").plot();\n\n\n\n\n\nda.frequencies\n\narray([0.055     , 0.0605    , 0.06655   , 0.073205  , 0.0805255 ,\n       0.08857805, 0.09743585, 0.10717944, 0.11789738, 0.12968713,\n       0.14265583, 0.15692142, 0.17261356, 0.18987492, 0.20886241,\n       0.22974865, 0.25272352, 0.27799585, 0.30579546, 0.336375  ,\n       0.3700125 , 0.40701374, 0.44771513, 0.49248663, 0.5417353 ],\n      dtype=float32)\n\n\nCompute significant wave height time series\n\nHm0 = da.to_Hm0()\nHm0\n\n<mikeio.DataArray>\nname: Significant wave height\ndims: (time:31)\ntime: 2017-10-27 00:00:00 - 2017-10-27 05:00:00 (31 records)\ngeometry: GeometryPoint2D(x=None, y=None)\nvalues: [1.61, 1.641, ..., 1.856]\n\n\n\nHm0.plot();\n\n\n\n\n\n\n\n\nfn = \"../tests/testdata/area_freq_spectra.dfsu\"\nda = mikeio.read(fn)[0]\nda\n\n<mikeio.DataArray>\nname: Directional integrated energy density\ndims: (time:3, element:40, frequency:25)\ntime: 2017-10-27 00:00:00 - 2017-10-27 05:00:00 (3 records)\ngeometry: DfsuSpectral2D (40 elements, 33 nodes)\n\n\n\nda.n_frequencies, da.n_directions\n\n(25, 0)\n\n\n\nda.plot();\n\n\n\n\n\nda.sel(x=2.7, y=52.4).plot();\n\n\n\n\n\nelem = 0\nplt.plot(da.frequencies, da[:,elem].to_numpy().T)\nplt.legend(da.time)\nplt.xlabel(\"frequency [Hz]\")\nplt.ylabel(\"directionally integrated energy [m*m*s]\")\nplt.title(f\"Area dfsu file, frequency spectrum in element {elem}\");\n\n\n\n\n\n\n\n\nDirectional spectra have 0 frequencies. They can be of type point, line and area.\n\n\n\nfn = \"../tests/testdata/line_dir_spectra.dfsu\"\nda = mikeio.read(fn)[0]\nda\n\n<mikeio.DataArray>\nname: Frequency integrated energy density\ndims: (time:4, node:10, direction:16)\ntime: 2017-10-27 00:00:00 - 2017-10-27 05:00:00 (4 records)\ngeometry: DfsuSpectral1D (9 elements, 10 nodes)\n\n\n\nda.n_frequencies, da.n_directions\n\n(0, 16)\n\n\n\nda5 = da.isel(time=0).isel(node=5)\nda5\n\n<mikeio.DataArray>\nname: Frequency integrated energy density\ndims: (direction:16)\ntime: 2017-10-27 00:00:00 (time-invariant)\ngeometry: Point Spectrum Geometry(frequency:0, direction:16, x:4.21642, y:52.90296)\nvalues: [0.04428, 0.01052, ..., 0.08194]\n\n\n\nda5.plot();"
  },
  {
    "objectID": "notebooks/Dfs0 - Relative time.html",
    "href": "notebooks/Dfs0 - Relative time.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "MIKE IO uses a pandas DatetimeIndex to represent the time dimension in dfs files. If the Dfs file has a relative time axis it will be converted to DatetimeIndex by using 1970-1-1 00:00:00 as start time.\n\nimport mikeio\n\n\nds = mikeio.read(\"../tests/testdata/eq_relative.dfs0\")\nds\n\n<mikeio.Dataset>\ndims: (time:504)\ntime: 1970-01-01 00:00:00 - 1970-01-01 00:00:56.237000 (504 non-equidistant records)\nitems:\n  0:  Item 1 <Undefined> (undefined)\n  1:  Item 2 <Undefined> (undefined)\n  2:  Item 3 <Undefined> (undefined)\n  3:  Item 4 <Undefined> (undefined)\n  4:  Item 5 <Undefined> (undefined)\n\n\n\ndf = ds.to_dataframe()\ndf.head()\n\n\n\n\n\n  \n    \n      \n      Item 1\n      Item 2\n      Item 3\n      Item 4\n      Item 5\n    \n  \n  \n    \n      1970-01-01 00:00:00.000\n      -0.006862\n      -0.000611\n      0.177047\n      32.484425\n      -304.720428\n    \n    \n      1970-01-01 00:00:00.112\n      -0.011746\n      -0.000611\n      0.189257\n      32.292774\n      -308.553406\n    \n    \n      1970-01-01 00:00:00.224\n      -0.006862\n      -0.000611\n      0.189257\n      32.292774\n      -308.553406\n    \n    \n      1970-01-01 00:00:00.335\n      -0.001978\n      0.004273\n      0.189257\n      32.292774\n      -300.887482\n    \n    \n      1970-01-01 00:00:00.447\n      0.002906\n      0.009157\n      0.177047\n      32.292774\n      -300.887482\n    \n  \n\n\n\n\nCorrecing the dataframe index by subtracting start time to get relative time axis.\n\ndf.index = (df.index - df.index[0]).total_seconds()\ndf.index.name = \"Relative time (s)\"\n\n\ndf.head()\n\n\n\n\n\n  \n    \n      \n      Item 1\n      Item 2\n      Item 3\n      Item 4\n      Item 5\n    \n    \n      Relative time (s)\n      \n      \n      \n      \n      \n    \n  \n  \n    \n      0.000\n      -0.006862\n      -0.000611\n      0.177047\n      32.484425\n      -304.720428\n    \n    \n      0.112\n      -0.011746\n      -0.000611\n      0.189257\n      32.292774\n      -308.553406\n    \n    \n      0.224\n      -0.006862\n      -0.000611\n      0.189257\n      32.292774\n      -308.553406\n    \n    \n      0.335\n      -0.001978\n      0.004273\n      0.189257\n      32.292774\n      -300.887482\n    \n    \n      0.447\n      0.002906\n      0.009157\n      0.177047\n      32.292774\n      -300.887482\n    \n  \n\n\n\n\n\ndf['Item 5'].plot();"
  },
  {
    "objectID": "notebooks/Dataset - plotting.html",
    "href": "notebooks/Dataset - plotting.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "For most plotting purposes the DataArray rather than the Dataset are used (see other other notebooks on how-to).\nBut for comparison of different items, the Dataset.plot method can be useful.\n\nimport mikeio\n\n\nds = mikeio.read(\"../tests/testdata/wind_north_sea.dfsu\")\nds\n\n<mikeio.Dataset>\ndims: (time:6, element:958)\ntime: 2017-10-27 00:00:00 - 2017-10-27 05:00:00 (6 records)\ngeometry: Dfsu2D (958 elements, 570 nodes)\nitems:\n  0:  Wind speed <Wind speed> (meter per sec)\n  1:  Wind direction <Wind Direction> (degree)\n\n\n\nds.plot.scatter(x=\"Wind speed\", y=\"Wind direction\");"
  },
  {
    "objectID": "notebooks/Dfs2 - Slicing.html",
    "href": "notebooks/Dfs2 - Slicing.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "import mikeio\nimport matplotlib.pyplot as plt\n\n\nds = mikeio.read(\"../tests/testdata/waves.dfs2\")\nds\n\n<mikeio.Dataset>\ndims: (time:3, y:31, x:31)\ntime: 2004-01-01 00:00:00 - 2004-01-03 00:00:00 (3 records)\ngeometry: Grid2D (ny=31, nx=31)\nitems:\n  0:  Sign. Wave Height <Significant wave height> (meter)\n  1:  Peak Wave Period <Wave period> (second)\n  2:  Mean Wave Direction <Mean Wave Direction> (degree)\n\n\n\nds[0].plot()\nplt.axvline(x=1400,color='k',linestyle='dashed', label=\"Transect\")\nplt.legend();\n\n\n\n\n\nUse Dataset/DataArray.sel with physical coordinates.\n\n\nds.sel(x=1400)[0].plot()\n\n<AxesSubplot: xlabel='y', ylabel='time'>\n\n\n\n\n\n\nUse grid coordinates with Dataset/DataArray.isel\n\n\nds.geometry.find_index(x=1400)\n\n(array([27]), None)\n\n\n\nds.isel(x=27)[0].plot()\n\n<AxesSubplot: xlabel='y', ylabel='time'>\n\n\n\n\n\n\nds.sel(x=1400).to_dfs(\"waves_x1400.dfs1\")\n\n\ndsnew = mikeio.read(\"waves_x1400.dfs1\")\ndsnew\n\n<mikeio.Dataset>\ndims: (time:3, x:31)\ntime: 2004-01-01 00:00:00 - 2004-01-03 00:00:00 (3 records)\ngeometry: Grid1D (n=31, dx=50)\nitems:\n  0:  Sign. Wave Height <Significant wave height> (meter)\n  1:  Peak Wave Period <Wave period> (second)\n  2:  Mean Wave Direction <Mean Wave Direction> (degree)\n\n\n\nimport os\nos.remove(\"waves_x1400.dfs1\")"
  },
  {
    "objectID": "notebooks/Dfs2 - Bathymetry.html",
    "href": "notebooks/Dfs2 - Bathymetry.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "Clean up\n\nimport os\nos.remove(\"gebco.dfs2\")"
  },
  {
    "objectID": "notebooks/DataArray - Dfsu plotting.html",
    "href": "notebooks/DataArray - Dfsu plotting.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "A DataArray with flexible mesh data, can be plotted in many different ways.\n\nimport matplotlib.pyplot as plt\nimport mikeio\n\n\n\n\nfn = \"../tests/testdata/oresundHD_run1.dfsu\"\nds = mikeio.read(fn)\nds\n\n<mikeio.Dataset>\ndims: (time:5, element:3612)\ntime: 2018-03-07 00:00:00 - 2018-03-11 00:00:00 (5 records)\ngeometry: Dfsu2D (3612 elements, 2046 nodes)\nitems:\n  0:  Surface elevation <Surface Elevation> (meter)\n  1:  Total water depth <Water Depth> (meter)\n  2:  U velocity <u velocity component> (meter per sec)\n  3:  V velocity <v velocity component> (meter per sec)\n\n\n\nda = ds[\"Surface elevation\"]\nda\n\n<mikeio.DataArray>\nname: Surface elevation\ndims: (time:5, element:3612)\ntime: 2018-03-07 00:00:00 - 2018-03-11 00:00:00 (5 records)\ngeometry: Dfsu2D (3612 elements, 2046 nodes)\n\n\n\n\n\n\n# default plot is a map, for multiple timestep data, the first timestep will be shown \nda.plot();\n\n\n\n\n\n# plot last time step as contour map\nda[-1].plot.contour(figsize=(5,8));\n\n\n\n\n\n_, ax = plt.subplots(1,2)\nda.plot.mesh(ax=ax[0]);\nda.plot.outline(ax=ax[1]);\n\n\n\n\n\n\n\nda.max().plot(title=\"Max\");\n\n\n\n\n\n# difference between last and first timestep\n(da[0] - da[-1]).plot.contourf(title=\"Difference\");\n\n\n\n\n\nda.mean(axis=\"space\").plot(title=\"Spatial mean as function of time\");\n\n\n\n\n\n\n\n\n\ntime series\nhistogram\n\n\n# plot all data as histogram\nda.plot.hist(bins=100);\n\n\n\n\n\n# plot all points as timeseries\nda.plot.line(alpha=0.01);\n\n\n\n\n\n\n\n\nfn = \"../tests/testdata/oresund_sigma_z.dfsu\"\ndfs = mikeio.open(fn)\ndfs\n\nDfsu3DSigmaZ\nnumber of elements: 17118\nnumber of nodes: 12042\nprojection: UTM-33\nnumber of sigma layers: 4\nmax number of z layers: 5\nitems:\n  0:  Temperature <Temperature> (degree Celsius)\n  1:  Salinity <Salinity> (PSU)\ntime: 3 steps with dt=10800.0s\n      1997-09-15 21:00:00 -- 1997-09-16 03:00:00\n\n\n\n\nIf only a specific layer is read, then all the standard 2d plotting can be used\n\nds = dfs.read(layers=\"top\")\nds\n\n<mikeio.Dataset>\ndims: (time:3, element:3700)\ntime: 1997-09-15 21:00:00 - 1997-09-16 03:00:00 (3 records)\ngeometry: Dfsu2D (3700 elements, 2090 nodes)\nitems:\n  0:  Temperature <Temperature> (degree Celsius)\n  1:  Salinity <Salinity> (PSU)\n\n\n\nds.geometry.is_2d\n\nTrue\n\n\n\nds[1].plot(); \n\n\n\n\n\n\n\n\nds = dfs.read() \nds\n\n<mikeio.Dataset>\ndims: (time:3, element:17118)\ntime: 1997-09-15 21:00:00 - 1997-09-16 03:00:00 (3 records)\ngeometry: Dfsu3DSigmaZ (17118 elements, 4 sigma-layers, 5 z-layers)\nitems:\n  0:  Temperature <Temperature> (degree Celsius)\n  1:  Salinity <Salinity> (PSU)\n\n\n\nds.geometry.is_2d\n\nFalse\n\n\n\nds[1].plot();"
  },
  {
    "objectID": "notebooks/Dataset - Concat, merge.html",
    "href": "notebooks/Dataset - Concat, merge.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "Datasets can be combined along the items and time axis\n\nimport matplotlib.pyplot as plt\nimport mikeio\n\n\n\n\nds1 = mikeio.read(\"../tests/testdata/tide1.dfs1\")\nds1\n\n<mikeio.Dataset>\ndims: (time:97, x:10)\ntime: 2019-01-01 00:00:00 - 2019-01-03 00:00:00 (97 records)\ngeometry: Grid1D (n=10, dx=0.06667)\nitems:\n  0:  Level <Water Level> (meter)\n\n\n\nds2 = mikeio.read(\"../tests/testdata/tide2.dfs1\") + 0.5  # add offset\nds2\n\n<mikeio.Dataset>\ndims: (time:97, x:10)\ntime: 2019-01-02 00:00:00 - 2019-01-04 00:00:00 (97 records)\ngeometry: Grid1D (n=10, dx=0.06667)\nitems:\n  0:  Level <Water Level> (meter)\n\n\nConcatenating data along the time axis can be done with Dataset.concat\n\nds3 = mikeio.Dataset.concat([ds1, ds2])\nds3\n\n<mikeio.Dataset>\ndims: (time:145, x:10)\ntime: 2019-01-01 00:00:00 - 2019-01-04 00:00:00 (145 records)\ngeometry: Grid1D (n=10, dx=0.06667)\nitems:\n  0:  Level <Water Level> (meter)\n\n\n\nplt.plot(ds1.time, ds1[0].to_numpy()[:,1], 'ro', label=\"Dataset 1\")\nplt.plot(ds2.time, ds2[0].to_numpy()[:,1], 'k+', label=\"Dataset 2\")\nplt.plot(ds3.time, ds3[0].to_numpy()[:,1], 'g-', label=\"Dataset 3\")\nplt.title(\"Notice the offset...\")\nplt.legend();\n\n\n\n\n\n\n\n\ndsA = mikeio.read(\"../tests/testdata/tide1.dfs1\")\ndsA\n\n<mikeio.Dataset>\ndims: (time:97, x:10)\ntime: 2019-01-01 00:00:00 - 2019-01-03 00:00:00 (97 records)\ngeometry: Grid1D (n=10, dx=0.06667)\nitems:\n  0:  Level <Water Level> (meter)\n\n\n\ndsB = dsA.copy()\ndsB = dsB.rename({\"Level\":\"Other_level\"})\ndsB = dsB + 2\ndsB\n\n<mikeio.Dataset>\ndims: (time:97, x:10)\ntime: 2019-01-01 00:00:00 - 2019-01-03 00:00:00 (97 records)\ngeometry: Grid1D (n=10, dx=0.06667)\nitems:\n  0:  Other_level <Water Level> (meter)\n\n\nMerge datasets with different items can be done like this:\n\ndsC = mikeio.Dataset.merge([dsA, dsB])\ndsC\n\n<mikeio.Dataset>\ndims: (time:97, x:10)\ntime: 2019-01-01 00:00:00 - 2019-01-03 00:00:00 (97 records)\ngeometry: Grid1D (n=10, dx=0.06667)\nitems:\n  0:  Level <Water Level> (meter)\n  1:  Other_level <Water Level> (meter)\n\n\nWhich in this simple case with a single item in each dataset is equivalent to:\n\ndaA = dsA[0]\ndaA\n\n<mikeio.DataArray>\nname: Level\ndims: (time:97, x:10)\ntime: 2019-01-01 00:00:00 - 2019-01-03 00:00:00 (97 records)\ngeometry: Grid1D (n=10, dx=0.06667)\n\n\n\ndaB = dsB[0]\ndaB\n\n<mikeio.DataArray>\nname: Other_level\ndims: (time:97, x:10)\ntime: 2019-01-01 00:00:00 - 2019-01-03 00:00:00 (97 records)\ngeometry: Grid1D (n=10, dx=0.06667)\n\n\n\nmikeio.Dataset([daA, daB])\n\n<mikeio.Dataset>\ndims: (time:97, x:10)\ntime: 2019-01-01 00:00:00 - 2019-01-03 00:00:00 (97 records)\ngeometry: Grid1D (n=10, dx=0.06667)\nitems:\n  0:  Level <Water Level> (meter)\n  1:  Other_level <Water Level> (meter)"
  },
  {
    "objectID": "notebooks/Generic.html",
    "href": "notebooks/Generic.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "Tools and methods that applies to any type of dfs files.\n\nmikeio.read()\nmikeio.generic: methods that read any dfs file and outputs a new dfs file of the same type\n\nconcat: Concatenates files along the time axis\n\nscale: Apply scaling to any dfs file\nsum: Sum two dfs files\ndiff: Calculate difference between two dfs files\nextract: Extract timesteps and/or items to a new dfs file\ntime-avg: Create a temporally averaged dfs file\nquantile: Create temporal quantiles of dfs file\n\n\n\nimport matplotlib.pyplot as plt\nimport mikeio\nimport mikeio.generic\n\n\n\nTake a look at these two files with overlapping timesteps.\n\nt1 = mikeio.read(\"../tests/testdata/tide1.dfs1\")\nt1\n\n<mikeio.Dataset>\ndims: (time:97, x:10)\ntime: 2019-01-01 00:00:00 - 2019-01-03 00:00:00 (97 records)\ngeometry: Grid1D (n=10, dx=0.06667)\nitems:\n  0:  Level <Water Level> (meter)\n\n\n\nt2 = mikeio.read(\"../tests/testdata/tide2.dfs1\")\nt2\n\n<mikeio.Dataset>\ndims: (time:97, x:10)\ntime: 2019-01-02 00:00:00 - 2019-01-04 00:00:00 (97 records)\ngeometry: Grid1D (n=10, dx=0.06667)\nitems:\n  0:  Level <Water Level> (meter)\n\n\nPlot one of the points along the line.\n\nplt.plot(t1.time,t1[0].isel(x=1).values, label=\"File 1\")\nplt.plot(t2.time,t2[0].isel(x=1).values,'k+', label=\"File 2\")\nplt.legend()\n\n<matplotlib.legend.Legend at 0x127e378f730>\n\n\n\n\n\n\nmikeio.generic.concat(infilenames=[\"../tests/testdata/tide1.dfs1\",\n                                   \"../tests/testdata/tide2.dfs1\"],\n                     outfilename=\"concat.dfs1\")\n\n\nc = mikeio.read(\"concat.dfs1\")\nc[0].isel(x=1).plot()\nc\n\n<mikeio.Dataset>\ndims: (time:145, x:10)\ntime: 2019-01-01 00:00:00 - 2019-01-04 00:00:00 (145 records)\ngeometry: Grid1D (n=10, dx=0.06667)\nitems:\n  0:  Level <Water Level> (meter)\n\n\n\n\n\n\n\n\nTake difference between two dfs files with same structure - e.g. to see the difference in result between two calibration runs\n\nfn1 = \"../tests/testdata/oresundHD_run1.dfsu\"\nfn2 = \"../tests/testdata/oresundHD_run2.dfsu\"\nfn_diff = \"oresundHD_difference.dfsu\"\nmikeio.generic.diff(fn1, fn2, fn_diff)\n\n100%|███████████████████████████████████████████████████████████████████████████████████| 5/5 [00:00<00:00, 999.36it/s]\n\n\n\n_, ax = plt.subplots(1,3, sharey=True, figsize=(12,5))\nda = mikeio.read(fn1, time=-1)[0]\nda.plot(vmin=0.06, vmax=0.27, ax=ax[0], title='run 1')\nda = mikeio.read(fn2, time=-1)[0]\nda.plot(vmin=0.06, vmax=0.27, ax=ax[1], title='run 2')\nda = mikeio.read(fn_diff, time=-1)[0]\nda.plot(vmin=-0.1, vmax=0.1, cmap='coolwarm', ax=ax[2], title='difference');\n\n\n\n\n\n\n\nThe extract() method can extract a part of a file:\n\ntime slice by specifying start and/or end\nspecific items\n\n\ninfile = \"../tests/testdata/tide1.dfs1\"\nmikeio.generic.extract(infile, \"extracted.dfs1\", start='2019-01-02')\n\n\ne = mikeio.read(\"extracted.dfs1\")\ne\n\n<mikeio.Dataset>\ndims: (time:49, x:10)\ntime: 2019-01-02 00:00:00 - 2019-01-03 00:00:00 (49 records)\ngeometry: Grid1D (n=10, dx=0.06667)\nitems:\n  0:  Level <Water Level> (meter)\n\n\n\ninfile = \"../tests/testdata/oresund_vertical_slice.dfsu\"\nmikeio.generic.extract(infile, \"extracted.dfsu\", items='Salinity', end=-2)\n\n\ne = mikeio.read(\"extracted.dfsu\")\ne\n\n<mikeio.Dataset>\ndims: (time:2, element:441)\ntime: 1997-09-15 21:00:00 - 1997-09-16 00:00:00 (2 records)\ngeometry: DfsuVerticalProfileSigmaZ (441 elements, 4 sigma-layers, 5 z-layers)\nitems:\n  0:  Salinity <Salinity> (PSU)\n\n\n\n\n\nAdding a constant e.g to adjust datum\n\nds = mikeio.read(\"../tests/testdata/gebco_sound.dfs2\")\nds.Elevation[0].plot();\n\n\n\n\n\nds['Elevation'][0,104,131].to_numpy()\n\n-1.0\n\n\nThis is the processing step.\n\nmikeio.generic.scale(\"../tests/testdata/gebco_sound.dfs2\", \n                     \"gebco_sound_local_datum.dfs2\",\n                     offset=-2.1\n                     )\n\n\nds2 = mikeio.read(\"gebco_sound_local_datum.dfs2\")\nds2['Elevation'][0].plot()\n\n<AxesSubplot:xlabel='Longitude [degrees]', ylabel='Latitude [degrees]'>\n\n\n\n\n\n\nds2['Elevation'][0,104,131].to_numpy()\n\n-3.1\n\n\n\n\n\nimport numpy as np\nfactor = np.ones_like(ds['Elevation'][0].to_numpy())\nfactor.shape\n\n(264, 216)\n\n\nAdd some spatially varying factors, exaggerated values for educational purpose.\n\nfactor[:,0:100] = 5.3\nfactor[0:40,] = 0.1\nfactor[150:,150:] = 10.7\nplt.imshow(factor)\nplt.colorbar();\n\n\n\n\nThe 2d array must first be flipped upside down and then converted to a 1d vector using numpy.ndarray.flatten to match how data is stored in dfs files.\n\nfactor_ud = np.flipud(factor)\nfactor_vec  = factor_ud.flatten()\nmikeio.generic.scale(\"../tests/testdata/gebco_sound.dfs2\", \n                     \"gebco_sound_spatial.dfs2\",\n                     factor=factor_vec\n                     )\n\n\nds3 = mikeio.read(\"gebco_sound_spatial.dfs2\")\nds3.Elevation[0].plot();\n\n\n\n\n\n\n\n\n\nfn = \"../tests/testdata/NorthSea_HD_and_windspeed.dfsu\"\nfn_avg = \"Avg_NorthSea_HD_and_windspeed.dfsu\"\nmikeio.generic.avg_time(fn, fn_avg)\n\n\nds = mikeio.read(fn)\nds.mean(axis=0).describe()   # alternative way of getting the time average\n\n\n\n\n\n  \n    \n      \n      Surface elevation\n      Wind speed\n    \n  \n  \n    \n      count\n      958.000000\n      958.000000\n    \n    \n      mean\n      0.449857\n      12.772706\n    \n    \n      std\n      0.178127\n      2.367667\n    \n    \n      min\n      0.114355\n      6.498364\n    \n    \n      25%\n      0.373691\n      11.199439\n    \n    \n      50%\n      0.431747\n      12.984060\n    \n    \n      75%\n      0.479224\n      14.658077\n    \n    \n      max\n      1.202888\n      16.677952\n    \n  \n\n\n\n\n\nds_avg = mikeio.read(fn_avg)\nds_avg.describe()\n\n\n\n\n\n  \n    \n      \n      Surface elevation\n      Wind speed\n    \n  \n  \n    \n      count\n      958.000000\n      958.000000\n    \n    \n      mean\n      0.449857\n      12.772706\n    \n    \n      std\n      0.178127\n      2.367667\n    \n    \n      min\n      0.114355\n      6.498364\n    \n    \n      25%\n      0.373691\n      11.199439\n    \n    \n      50%\n      0.431747\n      12.984060\n    \n    \n      75%\n      0.479224\n      14.658077\n    \n    \n      max\n      1.202888\n      16.677952\n    \n  \n\n\n\n\n\n\n\nExample that calculates the 25%, 50% and 75% percentile for all items in a dfsu file.\n\nfn = \"../tests/testdata/NorthSea_HD_and_windspeed.dfsu\"\nfn_q = \"Q_NorthSea_HD_and_windspeed.dfsu\"\nmikeio.generic.quantile(fn, fn_q, q=[0.25,0.5,0.75])\n\n\nds = mikeio.read(fn_q)\nds\n\n<mikeio.Dataset>\ndims: (time:1, element:958)\ntime: 2017-10-27 00:00:00 (time-invariant)\ngeometry: Dfsu2D (958 elements, 570 nodes)\nitems:\n  0:  Quantile 0.25, Surface elevation <Surface Elevation> (meter)\n  1:  Quantile 0.5, Surface elevation <Surface Elevation> (meter)\n  2:  Quantile 0.75, Surface elevation <Surface Elevation> (meter)\n  3:  Quantile 0.25, Wind speed <Wind speed> (meter per sec)\n  4:  Quantile 0.5, Wind speed <Wind speed> (meter per sec)\n  5:  Quantile 0.75, Wind speed <Wind speed> (meter per sec)\n\n\n\nda_q75 = ds[\"Quantile 0.75, Wind speed\"]\nda_q75.plot(title=\"75th percentile, wind speed\", label=\"m/s\");\n\n\n\n\n\n\n\n\nimport os\nos.remove(\"concat.dfs1\")\nos.remove(\"oresundHD_difference.dfsu\")\nos.remove(\"extracted.dfs1\")\nos.remove(\"extracted.dfsu\")\nos.remove(\"gebco_sound_local_datum.dfs2\")\nos.remove(\"gebco_sound_spatial.dfs2\")\nos.remove(\"Avg_NorthSea_HD_and_windspeed.dfsu\")\nos.remove(fn_q)"
  },
  {
    "objectID": "notebooks/DataArray - Arithmetic.html",
    "href": "notebooks/DataArray - Arithmetic.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "We can basic arithmetic operations (plus, minus, multiplication and division) with DataArrays, both with scalars, numpy arrays and other DataArrays. The output will in all cases be a new DataArray.\n\nimport mikeio\n\n\nfn1 = \"../tests/testdata/oresundHD_run1.dfsu\"\nda1 = mikeio.read(fn1, items=\"Surface elevation\")[0]\nfn2 = \"../tests/testdata/oresundHD_run2.dfsu\"\nda2 = mikeio.read(fn2, items=\"Surface elevation\")[0]\n\n\n\nWe can scale a DataArray or add a constant using *, +, / and -\n\nda1.values.mean()\n\n0.18681714\n\n\n\nda1_A = da1 + 1\nda1_B = da1 - 1\nda1_A.values.mean(), da1_B.values.mean()\n\n(1.1868172, -0.81318283)\n\n\n\nda1_C = da1 * 2\nda1_D = da1 / 2\nda1_C.values.mean(), da1_D.values.mean()\n\n(0.37363428, 0.09340857)\n\n\n\n\n\nAssume that we have two calibration runs and we wan’t to find the difference…\n\nda_diff = da1-da2\nda_diff.plot(title=\"Difference\");\n\n\n\n\n\nda_diff = da1/da2\nda_diff.plot(title=\"da1/da2\");"
  },
  {
    "objectID": "notebooks/Dfs3 - Basic.html",
    "href": "notebooks/Dfs3 - Basic.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "import matplotlib.pyplot as plt\nimport mikeio\n\n\nds = mikeio.read(\"../tests/testdata/dissolved_oxygen.dfs3\")\nds\n\n<mikeio.Dataset>\ndims: (time:1, z:17, y:112, x:91)\ntime: 2001-12-28 00:00:00 (time-invariant)\ngeometry: Grid3D(nz=17, ny=112, nx=91)\nitems:\n  0:  Diss. oxygen (mg/l) <Concentration 3> (mg per liter)\n\n\n\nds.geometry\n\n<mikeio.Grid3D>\nx: [0, 150, ..., 1.35e+04] (nx=91, dx=150)\ny: [0, 150, ..., 1.665e+04] (ny=112, dy=150)\nz: [0, 1, ..., 16] (nz=17, dz=1)\norigin: (10.37, 55.42), orientation: 18.125\nprojection: PROJCS[\"UTM-32\",GEOGCS[\"Unused\",DATUM[\"UTM Projections\",SPHEROID[\"WGS 1984\",6378137,298.257223563]],PRIMEM[\"Greenwich\",0],UNIT[\"Degree\",0.0174532925199433]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"False_Easting\",500000],PARAMETER[\"False_Northing\",0],PARAMETER[\"Central_Meridian\",9],PARAMETER[\"Scale_Factor\",0.9996],PARAMETER[\"Latitude_Of_Origin\",0],UNIT[\"Meter\",1]]\n\n\n\ndo  = ds[0]\ndo\n\n<mikeio.DataArray>\nname: Diss. oxygen (mg/l)\ndims: (time:1, z:17, y:112, x:91)\ntime: 2001-12-28 00:00:00 (time-invariant)\ngeometry: Grid3D(nz=17, ny=112, nx=91)\n\n\n\ndo.isel(z=-1).plot();\n\n\n\n\n\ndst = mikeio.read(\"../tests/testdata/dissolved_oxygen.dfs3\", layers=\"top\")\n\n\ndst\n\n<mikeio.Dataset>\ndims: (time:1, y:112, x:91)\ntime: 2001-12-28 00:00:00 (time-invariant)\ngeometry: Grid2D (ny=112, nx=91)\nitems:\n  0:  Diss. oxygen (mg/l) <Concentration 3> (mg per liter)\n\n\n\ndst[0].plot();\n\n\n\n\n\ndsb = mikeio.read(\"../tests/testdata/dissolved_oxygen.dfs3\",layers=\"bottom\")\ndsb\n\n<mikeio.Dataset>\ndims: (time:1, y:112, x:91)\ntime: 2001-12-28 00:00:00 (time-invariant)\ngeometry: Grid2D (ny=112, nx=91)\nitems:\n  0:  Diss. oxygen (mg/l) <Concentration 3> (mg per liter)\n\n\n\ndsb[0].plot(figsize=(10,10))\nplt.title(\"Bottom oxygen\");\n\n\n\n\n\ndsb[0].to_numpy()[0,110,56]\n\n11.076560020446777\n\n\n\ndst[0].to_numpy()[0,110,56]\n\n12.409002304077148\n\n\n\ndsb[0].to_numpy()[0,58,52]\n\n0.05738005042076111"
  },
  {
    "objectID": "notebooks/Dfsu - Speed and direction.html",
    "href": "notebooks/Dfsu - Speed and direction.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "import numpy as np\nimport mikeio\n\n\nds = mikeio.read(\"../tests/testdata/HD2D.dfsu\")\nds\n\n<mikeio.Dataset>\nGeometry: Dfsu2D\nDimensions: (time:9, element:884)\nTime: 1985-08-06 07:00:00 - 1985-08-07 03:00:00 (9 records)\nItems:\n  0:  Surface elevation <Surface Elevation> (meter)\n  1:  U velocity <u velocity component> (meter per sec)\n  2:  V velocity <v velocity component> (meter per sec)\n  3:  Current speed <Current Speed> (meter per sec)\n\n\nThis file is missing current direction :-(\nLets’fix that!\n\n\n\nds.U_velocity\n\n<mikeio.DataArray>\nName: U velocity\nGeometry: Dfsu2D\nDimensions: (time:9, element:884)\nTime: 1985-08-06 07:00:00 - 1985-08-07 03:00:00 (9 records)\n\n\nIn order to use Numpy functions on a DataArray, we first convert the DataArrays (U, V) to standard NumPy ndarrays.\n\nu = ds.U_velocity.to_numpy()\nv = ds.V_velocity.to_numpy()\n\n\ndirection = np.mod(90 -np.rad2deg(np.arctan2(v,u)),360)\n\n\n\n\n\nfrom mikeio.eum import ItemInfo, EUMUnit, EUMType\n\nds[\"Current direction\"] = mikeio.DataArray(direction, time= ds.time, item = ItemInfo(\"Current direction\", EUMType.Current_Direction, EUMUnit.degree), geometry=ds.geometry)\nds\n\n<mikeio.Dataset>\nGeometry: Dfsu2D\nDimensions: (time:9, element:884)\nTime: 1985-08-06 07:00:00 - 1985-08-07 03:00:00 (9 records)\nItems:\n  0:  Surface elevation <Surface Elevation> (meter)\n  1:  U velocity <u velocity component> (meter per sec)\n  2:  V velocity <v velocity component> (meter per sec)\n  3:  Current speed <Current Speed> (meter per sec)\n  4:  Current direction <Current Direction> (degree)\n\n\n\nds.to_dfs(\"speed_direction.dfsu\")\n\n\nnds = mikeio.read(\"speed_direction.dfsu\")\nnds\n\n<mikeio.Dataset>\nGeometry: Dfsu2D\nDimensions: (time:9, element:884)\nTime: 1985-08-06 07:00:00 - 1985-08-07 03:00:00 (9 records)\nItems:\n  0:  Surface elevation <Surface Elevation> (meter)\n  1:  U velocity <u velocity component> (meter per sec)\n  2:  V velocity <v velocity component> (meter per sec)\n  3:  Current speed <Current Speed> (meter per sec)\n  4:  Current direction <Current Direction> (degree)"
  },
  {
    "objectID": "notebooks/Dfsu - Speed and direction.html#plot-quiver-on-cartesian-overlay-instead",
    "href": "notebooks/Dfsu - Speed and direction.html#plot-quiver-on-cartesian-overlay-instead",
    "title": "mikeio-examples",
    "section": "Plot quiver on Cartesian overlay instead",
    "text": "Plot quiver on Cartesian overlay instead\nCreate overset grid and interpolate data on to this\n\ng = ds.geometry.get_overset_grid(dx=50)\ng\n\n<mikeio.Grid2D>\nx-axis: nx=33 points from x0=605902 to x1=607502 with dx=50\ny-axis: ny=93 points from y0=6.90242e+06 to y1=6.90702e+06 with dy=50\nNumber of grid points: 3069\n\n\n\ng.projection\n\n'UTM-29'\n\n\n\nui = ds.U_velocity.interp_like(g)\nvi = ds.V_velocity.interp_like(g)\n\n\nui.plot();\n\n\n\n\n\nax = ds.Current_speed.plot(figsize=(10,10))\n\nu = ui.to_numpy()\nv = vi.to_numpy()\nax.quiver(g.x, g.y, u[step], v[step], scale=8, minshaft=5)\n\nax.set_ylim([None, 6903000])\nax.set_xlim([607000, None])\nax.set_title(f'Current speed with overset grid; {ds.time[step]}')\nax.set_xlabel(\"Easting (m)\")\nax.set_ylabel(\"Northing (m)\");"
  },
  {
    "objectID": "notebooks/Dfsu - Speed and direction.html#clean-up",
    "href": "notebooks/Dfsu - Speed and direction.html#clean-up",
    "title": "mikeio-examples",
    "section": "Clean up",
    "text": "Clean up\n\nimport os\nos.remove(\"speed_direction.dfsu\")"
  },
  {
    "objectID": "notebooks/DataArray - Dfs123 plotting.html",
    "href": "notebooks/DataArray - Dfs123 plotting.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "A DataArray with gridded data, can be plotted in many different ways.\n\nimport matplotlib.pyplot as plt\nimport mikeio\n\n\n\n\nds = mikeio.read(\"../tests/testdata/vu_tide_hourly.dfs1\")\nds = ds.rename({\"Tidal current component (geographic East)\":\"Tidal current u-comp\"})\nda = ds[\"Tidal current u-comp\"]\nda\n\n<mikeio.DataArray>\nname: Tidal current u-comp\ndims: (time:721, x:11)\ntime: 2021-08-01 00:00:00 - 2021-08-31 00:00:00 (721 records)\ngeometry: Grid1D (n=11, dx=0.09818)\n\n\n\nda.geometry\n\n<mikeio.Grid1D>\nx: [0, 0.09818, ..., 0.9818] (nx=11, dx=0.09818)\n\n\n\nda[0:10:2].plot();\n\n\n\n\n\nda[0:10:2].plot.line()\nplt.legend(da.time[0:10:2]);\n\n\n\n\n\n# plot all points on line as time series\nda.plot.timeseries();\n\n\n\n\n\n# first 48 hours...  \nda[:49].plot.pcolormesh();\n\n\n\n\n\n# single point on line as timeseries\nda.sel(x=0.5).sel(time=slice(\"2021-08-01\",\"2021-08-03\")).plot();\n\n\n\n\n\n# all data as histogram\nda.plot.hist(bins=40);\n\n\n\n\n\n\n\n\nda = mikeio.read(\"../tests/testdata/gebco_sound.dfs2\")[0]\nda\n\n<mikeio.DataArray>\nname: Elevation\ndims: (time:1, y:264, x:216)\ntime: 2020-05-15 11:04:52 (time-invariant)\ngeometry: Grid2D (ny=264, nx=216)\n\n\n\nda.geometry\n\n<mikeio.Grid2D>\nx: [12.2, 12.21, ..., 13.1] (nx=216, dx=0.004167)\ny: [55.2, 55.21, ..., 56.3] (ny=264, dy=0.004167)\nprojection: LONG/LAT\n\n\n\nda.plot(figsize=(10,6));\n\n\n\n\nIt is also possible to customize the labels of the axes as well as the color bar, e.g. for localized adaption.\n\nda.plot.contourf(figsize=(10,6), levels=4, label=\"Højde (m)\");\nplt.xlabel(\"Længdekreds (°)\")\nplt.ylabel(\"Breddekreds (°)\")\n\nText(0, 0.5, 'Breddekreds (°)')\n\n\n\n\n\n\nax = da.plot.contour(figsize=(8,8), cmap=\"plasma\")\nax.set_xlim([12.5, 12.9]);\nax.set_ylim([55.8, 56]);\n\n\n\n\n\nda.plot.hist(bins=20);\n\n\n\n\n\n\n\n\nfn = \"../tests/testdata/test_dfs3.dfs3\"\ndfs = mikeio.open(fn)\ndfs\n\n<mikeio.Dfs3>\ngeometry: Grid3D(nz=34, ny=17, nx=21)\nitems:\n  0:  Temperature <Temperature> (degree Kelvin)\ntime: 2 steps\nstart time: 2020-12-30 00:00:00\n\n\n\ndfs.geometry\n\n<mikeio.Grid3D>\nx: [0, 0.25, ..., 5] (nx=21, dx=0.25)\ny: [0, 0.25, ..., 4] (ny=17, dy=0.25)\nz: [0, 1, ..., 33] (nz=34, dz=1)\norigin: (10, 54), orientation: 0.000\nprojection: LONG/LAT\n\n\n\nds=dfs.read()\nds\n\n<mikeio.Dataset>\ndims: (time:2, z:34, y:17, x:21)\ntime: 2020-12-30 00:00:00 - 2020-12-30 01:00:00 (2 records)\ngeometry: Grid3D(nz=34, ny=17, nx=21)\nitems:\n  0:  Temperature <Temperature> (degree Kelvin)\n\n\n\nds.Temperature.plot();\n\n\n\n\n\nax = ds.Temperature[:,0,:,:].plot.contourf();\nax.grid()\n\n\n\n\n\nds.Temperature[:,0,:,0].plot();\n\n\n\n\n\nds=dfs.read(layers=0)\nds\n\n<mikeio.Dataset>\ndims: (time:2, y:17, x:21)\ntime: 2020-12-30 00:00:00 - 2020-12-30 01:00:00 (2 records)\ngeometry: Grid2D (ny=17, nx=21)\nitems:\n  0:  Temperature <Temperature> (degree Kelvin)\n\n\n\nds.Temperature.plot();"
  },
  {
    "objectID": "notebooks/Dfsu - Extract Track.html",
    "href": "notebooks/Dfsu - Extract Track.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "Load dfsu result file\nThe file contains surface elevation and wind speed model data. We wish to compare the model data with altimetry data\n\ntrack_file = '../tests/testdata/altimetry_NorthSea_20171027.csv'\ndata_file = '../tests/testdata/NorthSea_HD_and_windspeed.dfsu'\n\n\ndfs = mikeio.open(data_file)\ndfs\n\nDfsu2D\nnumber of elements: 958\nnumber of nodes: 570\nprojection: LONG/LAT\nitems:\n  0:  Surface elevation <Surface Elevation> (meter)\n  1:  Wind speed <Wind speed> (meter per sec)\ntime: 67 steps with dt=3600.0s\n      2017-10-27 00:00:00 -- 2017-10-29 18:00:00\n\n\n\n\nLoad and visualize altimetry tracks\nThe altimetry data is stored in a csv file. We plot the data on top of the dfsu mesh.\n\ntrack = pd.read_csv(track_file, index_col=0, parse_dates=True)\n\n\ntrack.head()\n\n\n\n\n\n  \n    \n      \n      lon\n      lat\n      surface_elevation\n      significant_wave_height\n      wind_speed\n    \n    \n      date\n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2017-10-26 04:37:37\n      8.757272\n      53.926136\n      1.6449\n      0.426\n      6.100000\n    \n    \n      2017-10-26 04:37:54\n      8.221631\n      54.948459\n      1.1200\n      1.634\n      9.030000\n    \n    \n      2017-10-26 04:37:55\n      8.189390\n      55.008547\n      1.0882\n      1.717\n      9.370000\n    \n    \n      2017-10-26 04:37:56\n      8.157065\n      55.068627\n      1.0309\n      1.869\n      9.559999\n    \n    \n      2017-10-26 04:37:58\n      8.124656\n      55.128700\n      1.0369\n      1.939\n      9.980000\n    \n  \n\n\n\n\n\nax = dfs.geometry.plot.mesh(figsize=(8,7))\ntrack.plot.scatter('lon','lat', ax=ax);\n\n\n\n\n\ntrack_xy = track[['lon','lat']].values\nprint(f'Inside domain: {sum(dfs.contains(track_xy))} points of the track (total: {len(track_xy)})')\n\nInside domain: 922 points of the track (total: 1115)\n\n\n\n\nExtract track data from dfsu file\nThe extract_track() takes a track definition (time, longitude, latitude of each point) as either a dataframe, a csv-file, a dfs0 file or a mikeio.Dataset.\n\ne_track = dfs.extract_track(track_file)\n\n\n# convert to dataframe and rename columns\ndf = e_track.to_dataframe()\ndf.columns = ['Longitude', 'Latitude', 'Model_surface_elevation', 'Model_wind_speed']\n\n\n\nCompare with the observed altimetry values\n\ndf['Obs_surface_elevation'] = track['surface_elevation']\ndf['Obs_wind_speed'] = track['wind_speed']\ndf.dropna(inplace=True)\n\n\nresi = df.Model_wind_speed - df.Obs_wind_speed\nbias = resi.median()\nrmse = np.sqrt(np.mean(resi**2))\nprint(f'Wind speed: bias={bias:.2f}m/s, rmse={rmse:.2f}m/s')\n\nWind speed: bias=0.68m/s, rmse=2.05m/s\n\n\n\ndf.plot.scatter('Obs_wind_speed','Model_wind_speed')\nplt.plot([0,25],[0,25], color='r')\nplt.gca().set_aspect('equal')\n\n\n\n\n\nresi = df.Model_surface_elevation - df.Obs_surface_elevation\nbias = resi.median()\nrmse = np.sqrt(np.mean(resi**2))\nprint(f'Surface elevation: bias={100*bias:.2f}cm, rmse={100*rmse:.2f}cm')\n\nSurface elevation: bias=-6.34cm, rmse=11.50cm\n\n\n\ndf.plot.scatter('Obs_surface_elevation','Model_surface_elevation')\nplt.plot([-0.6,2.5],[-0.6,2.5], color='r')\nplt.gca().set_aspect('equal')"
  },
  {
    "objectID": "notebooks/Dfs0 - CMEMS insitu.html",
    "href": "notebooks/Dfs0 - CMEMS insitu.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "import pandas as pd\nimport xarray as xr\nimport mikeio\n\n\nfino = xr.open_dataset(\"../tests/testdata/NO_TS_MO_FINO1_202209.nc\")\nfino\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.Dataset>\nDimensions:      (TIME: 2879, LATITUDE: 2879, LONGITUDE: 2879, DEPTH: 7,\n                  POSITION: 2879)\nCoordinates:\n  * TIME         (TIME) datetime64[ns] 2022-09-01 ... 2022-09-30T23:31:59.999...\n  * LATITUDE     (LATITUDE) float32 54.0 54.0 54.0 54.0 ... 54.0 54.0 54.0 54.0\n  * LONGITUDE    (LONGITUDE) float32 6.583 6.583 6.583 ... 6.583 6.583 6.583\n    DEPH         (TIME, DEPTH) float32 0.0 0.5 3.0 6.0 ... 6.0 10.0 15.0 25.0\nDimensions without coordinates: DEPTH, POSITION\nData variables: (12/22)\n    DEPH_QC      (TIME, DEPTH) float32 7.0 7.0 7.0 7.0 7.0 ... 7.0 7.0 7.0 7.0\n    TIME_QC      (TIME) float32 1.0 1.0 1.0 1.0 1.0 1.0 ... 1.0 1.0 1.0 1.0 1.0\n    POSITION_QC  (POSITION) float32 7.0 7.0 7.0 7.0 7.0 ... 7.0 7.0 7.0 7.0 7.0\n    TEMP         (TIME, DEPTH) float64 nan nan nan nan nan ... nan nan nan nan\n    TEMP_QC      (TIME, DEPTH) float32 nan 9.0 9.0 9.0 9.0 ... 9.0 9.0 9.0 9.0\n    VHM0         (TIME, DEPTH) float64 nan nan nan nan nan ... nan nan nan nan\n    ...           ...\n    VTPK_DM      (TIME, DEPTH) object nan nan nan nan nan ... nan nan nan nan\n    VTZA         (TIME, DEPTH) float64 4.12 nan nan nan nan ... nan nan nan nan\n    VTZA_QC      (TIME, DEPTH) float32 1.0 nan nan nan nan ... nan nan nan nan\n    VPED         (TIME, DEPTH) float64 nan nan nan nan nan ... nan nan nan nan\n    VPED_QC      (TIME, DEPTH) float32 9.0 nan nan nan nan ... nan nan nan nan\n    VPED_DM      (TIME, DEPTH) object nan nan nan nan nan ... nan nan nan nan\nAttributes: (12/46)\n    platform_code:                  FINO1\n    platform_name:                  \n    data_mode:                      M\n    title:                          NWS - NRT in situ Observations\n    summary:                        Oceanographic data from North West Shelf\n    naming_authority:               Copernicus Marine In Situ\n    ...                             ...\n    doi:                            \n    pi_name:                        \n    qc_manual:                      OceanSITES User's Manual v1.2\n    date_update:                    2022-10-07T05:39:40Z\n    history:                        2022-10-01T18:04:25Z : Creation; 2022-10-...\n    wmo_inst_type:                  xarray.DatasetDimensions:TIME: 2879LATITUDE: 2879LONGITUDE: 2879DEPTH: 7POSITION: 2879Coordinates: (4)TIME(TIME)datetime64[ns]2022-09-01 ... 2022-09-30T23:31:...long_name :Timestandard_name :timevalid_min :-90000.0valid_max :90000.0uncertainty : comment : axis :Tancillary_variables :TIME_QCarray(['2022-09-01T00:00:00.000000000', '2022-09-01T00:02:00.000000000',\n       '2022-09-01T00:30:00.000000000', ..., '2022-09-30T23:02:00.000000000',\n       '2022-09-30T23:30:00.000000000', '2022-09-30T23:31:59.999999744'],\n      dtype='datetime64[ns]')LATITUDE(LATITUDE)float3254.0 54.0 54.0 ... 54.0 54.0 54.0long_name :Latitude of each locationstandard_name :latitudeunits :degree_northvalid_min :-90.0valid_max :90.0uncertainty :comment :axis :Yancillary_variables :POSITION_QCarray([54., 54., 54., ..., 54., 54., 54.], dtype=float32)LONGITUDE(LONGITUDE)float326.583 6.583 6.583 ... 6.583 6.583long_name :Longitude of each locationstandard_name :longitudeunits :degree_eastvalid_min :-180.0valid_max :180.0uncertainty :comment :axis :Xancillary_variables :POSITION_QCarray([6.583333, 6.583333, 6.583333, ..., 6.583333, 6.583333, 6.583333],\n      dtype=float32)DEPH(TIME, DEPTH)float32...long_name :Depthstandard_name :depthunits :mpositive :downvalid_min :-12000.0valid_max :12000.0uncertainty :comment :axis :Zreference :sea_leveldata_mode :Rancillary_variables :DEPH_QCarray([[ 0. ,  0.5,  3. , ..., 10. , 15. , 25. ],\n       [ 0. ,  0.5,  3. , ..., 10. , 15. , 25. ],\n       [ 0. ,  0.5,  3. , ..., 10. , 15. , 25. ],\n       ...,\n       [ 0. ,  0.5,  3. , ..., 10. , 15. , 25. ],\n       [ 0. ,  0.5,  3. , ..., 10. , 15. , 25. ],\n       [ 0. ,  0.5,  3. , ..., 10. , 15. , 25. ]], dtype=float32)Data variables: (22)DEPH_QC(TIME, DEPTH)float32...long_name :Depth quality flagconventions :Copernicus Marine In Situ reference table 2valid_min :0valid_max :9flag_values :[0 1 2 3 4 5 6 7 8 9]flag_meanings :no_qc_performed good_data probably_good_data bad_data_that_are_potentially_correctable bad_data value_changed value_below_detection nominal_value interpolated_value missing_valuearray([[7., 7., 7., ..., 7., 7., 7.],\n       [7., 7., 7., ..., 7., 7., 7.],\n       [7., 7., 7., ..., 7., 7., 7.],\n       ...,\n       [7., 7., 7., ..., 7., 7., 7.],\n       [7., 7., 7., ..., 7., 7., 7.],\n       [7., 7., 7., ..., 7., 7., 7.]], dtype=float32)TIME_QC(TIME)float32...long_name :Time quality flagconventions :Copernicus Marine In Situ reference table 2valid_min :0valid_max :9flag_values :[0 1 2 3 4 5 6 7 8 9]flag_meanings :no_qc_performed good_data probably_good_data bad_data_that_are_potentially_correctable bad_data value_changed value_below_detection nominal_value interpolated_value missing_valuearray([1., 1., 1., ..., 1., 1., 1.], dtype=float32)POSITION_QC(POSITION)float32...long_name :Position quality flagconventions :Copernicus Marine In Situ reference table 2valid_min :0valid_max :9flag_values :[0 1 2 3 4 5 6 7 8 9]flag_meanings :no_qc_performed good_data probably_good_data bad_data_that_are_potentially_correctable bad_data value_changed value_below_detection nominal_value interpolated_value missing_valuearray([7., 7., 7., ..., 7., 7., 7.], dtype=float32)TEMP(TIME, DEPTH)float64...standard_name :sea_water_temperatureunits :degrees_Clong_name :Sea temperaturevalid_min :-2000valid_max :32000comment : uncertainty : accuracy : precision : resolution : cell_methods : sensor_depth :0.0sensor_mount : sensor_orientation : data_mode :Rancillary_variables :TEMP_QCarray([[      nan,       nan,       nan, ...,       nan,       nan,       nan],\n       [      nan, 19.400001,       nan, ...,       nan,       nan,       nan],\n       [      nan,       nan,       nan, ...,       nan,       nan,       nan],\n       ...,\n       [      nan, 16.950001,       nan, ...,       nan,       nan,       nan],\n       [      nan,       nan,       nan, ...,       nan,       nan,       nan],\n       [      nan, 16.950001,       nan, ...,       nan,       nan,       nan]])TEMP_QC(TIME, DEPTH)float32...long_name :Sea temperature quality flagconventions :Copernicus Marine In Situ reference table 2valid_min :0valid_max :9flag_values :[0 1 2 3 4 5 6 7 8 9]flag_meanings :no_qc_performed good_data probably_good_data bad_data_that_are_potentially_correctable bad_data value_changed value_below_detection nominal_value interpolated_value missing_valuearray([[nan,  9.,  9., ...,  9.,  9.,  9.],\n       [nan,  1.,  9., ...,  9.,  9.,  9.],\n       [nan,  9.,  9., ...,  9.,  9.,  9.],\n       ...,\n       [nan,  1.,  9., ...,  9.,  9.,  9.],\n       [nan,  9.,  9., ...,  9.,  9.,  9.],\n       [nan,  1.,  9., ...,  9.,  9.,  9.]], dtype=float32)VHM0(TIME, DEPTH)float64...standard_name :sea_surface_wave_significant_heightunits :mlong_name :Spectral significant wave height (Hm0)valid_min :1valid_max :25000comment : uncertainty : accuracy : precision : resolution : cell_methods : type_of_analysis :spectral analysissensor_depth :0.0sensor_mount : sensor_orientation : data_mode :Mancillary_variables :VHM0_QC VHM0_DMarray([[ nan,  nan,  nan, ...,  nan,  nan,  nan],\n       [1.11,  nan,  nan, ...,  nan,  nan,  nan],\n       [ nan,  nan,  nan, ...,  nan,  nan,  nan],\n       ...,\n       [2.41,  nan,  nan, ...,  nan,  nan,  nan],\n       [ nan,  nan,  nan, ...,  nan,  nan,  nan],\n       [2.51,  nan,  nan, ...,  nan,  nan,  nan]])VHM0_QC(TIME, DEPTH)float32...long_name :Spectral significant wave height (Hm0) quality flagconventions :Copernicus Marine In Situ reference table 2valid_min :0valid_max :9flag_values :[0 1 2 3 4 5 6 7 8 9]flag_meanings :no_qc_performed good_data probably_good_data bad_data_that_are_potentially_correctable bad_data value_changed value_below_detection nominal_value interpolated_value missing_valuearray([[ 9., nan, nan, ..., nan, nan, nan],\n       [ 1., nan, nan, ..., nan, nan, nan],\n       [ 9., nan, nan, ..., nan, nan, nan],\n       ...,\n       [ 1., nan, nan, ..., nan, nan, nan],\n       [ 9., nan, nan, ..., nan, nan, nan],\n       [ 1., nan, nan, ..., nan, nan, nan]], dtype=float32)VHM0_DM(TIME, DEPTH)object...long_name :Spectral significant wave height (Hm0) method of data processingconventions :Copernicus Marine In Situ reference table 1flag_values :R, A, Dflag_meanings :real-time adjusted-in-real-time delayed-modearray([[nan, nan, nan, ..., nan, nan, nan],\n       [b'R', nan, nan, ..., nan, nan, nan],\n       [nan, nan, nan, ..., nan, nan, nan],\n       ...,\n       [b'R', nan, nan, ..., nan, nan, nan],\n       [nan, nan, nan, ..., nan, nan, nan],\n       [b'R', nan, nan, ..., nan, nan, nan]], dtype=object)VZMX(TIME, DEPTH)float64...standard_name :sea_surface_wave_maximum_heightunits :mlong_name :Maximum zero crossing wave height (Hmax)valid_min :0valid_max :40000comment : uncertainty : accuracy : precision : resolution : cell_methods : type_of_analysis :zero crossingsensor_depth :0.0sensor_mount : sensor_orientation : data_mode :Mancillary_variables :VZMX_QC VZMX_DMarray([[1.71,  nan,  nan, ...,  nan,  nan,  nan],\n       [ nan,  nan,  nan, ...,  nan,  nan,  nan],\n       [1.77,  nan,  nan, ...,  nan,  nan,  nan],\n       ...,\n       [ nan,  nan,  nan, ...,  nan,  nan,  nan],\n       [4.19,  nan,  nan, ...,  nan,  nan,  nan],\n       [ nan,  nan,  nan, ...,  nan,  nan,  nan]])VZMX_QC(TIME, DEPTH)float32...long_name :Maximum zero crossing wave height (Hmax) quality flagconventions :Copernicus Marine In Situ reference table 2valid_min :0valid_max :9flag_values :[0 1 2 3 4 5 6 7 8 9]flag_meanings :no_qc_performed good_data probably_good_data bad_data_that_are_potentially_correctable bad_data value_changed value_below_detection nominal_value interpolated_value missing_valuearray([[ 1., nan, nan, ..., nan, nan, nan],\n       [ 9., nan, nan, ..., nan, nan, nan],\n       [ 1., nan, nan, ..., nan, nan, nan],\n       ...,\n       [ 9., nan, nan, ..., nan, nan, nan],\n       [ 1., nan, nan, ..., nan, nan, nan],\n       [ 9., nan, nan, ..., nan, nan, nan]], dtype=float32)VZMX_DM(TIME, DEPTH)object...long_name :Maximum zero crossing wave height (Hmax) method of data processingconventions :Copernicus Marine In Situ reference table 1flag_values :R, A, Dflag_meanings :real-time adjusted-in-real-time delayed-modearray([[b'R', nan, nan, ..., nan, nan, nan],\n       [nan, nan, nan, ..., nan, nan, nan],\n       [b'R', nan, nan, ..., nan, nan, nan],\n       ...,\n       [nan, nan, nan, ..., nan, nan, nan],\n       [b'R', nan, nan, ..., nan, nan, nan],\n       [nan, nan, nan, ..., nan, nan, nan]], dtype=object)VTM02(TIME, DEPTH)float64...standard_name :sea_surface_wave_mean_period_from_variance_spectral_density_second_frequency_momentunits :slong_name :Spectral moments (0,2) wave period (Tm02)valid_min :1000valid_max :25000comment : uncertainty : accuracy : precision : resolution : cell_methods : type_of_analysis :spectral analysissensor_depth :0.0sensor_mount : sensor_orientation : data_mode :Mancillary_variables :VTM02_QC VTM02_DMarray([[  nan,   nan,   nan, ...,   nan,   nan,   nan],\n       [4.   ,   nan,   nan, ...,   nan,   nan,   nan],\n       [  nan,   nan,   nan, ...,   nan,   nan,   nan],\n       ...,\n       [4.878,   nan,   nan, ...,   nan,   nan,   nan],\n       [  nan,   nan,   nan, ...,   nan,   nan,   nan],\n       [5.063,   nan,   nan, ...,   nan,   nan,   nan]])VTM02_QC(TIME, DEPTH)float32...long_name :Spectral moments (0,2) wave period (Tm02) quality flagconventions :Copernicus Marine In Situ reference table 2valid_min :0valid_max :9flag_values :[0 1 2 3 4 5 6 7 8 9]flag_meanings :no_qc_performed good_data probably_good_data bad_data_that_are_potentially_correctable bad_data value_changed value_below_detection nominal_value interpolated_value missing_valuearray([[ 9., nan, nan, ..., nan, nan, nan],\n       [ 1., nan, nan, ..., nan, nan, nan],\n       [ 9., nan, nan, ..., nan, nan, nan],\n       ...,\n       [ 1., nan, nan, ..., nan, nan, nan],\n       [ 9., nan, nan, ..., nan, nan, nan],\n       [ 1., nan, nan, ..., nan, nan, nan]], dtype=float32)VTM02_DM(TIME, DEPTH)object...long_name :Spectral moments (0,2) wave period (Tm02) method of data processingconventions :Copernicus Marine In Situ reference table 1flag_values :R, A, Dflag_meanings :real-time adjusted-in-real-time delayed-modearray([[nan, nan, nan, ..., nan, nan, nan],\n       [b'R', nan, nan, ..., nan, nan, nan],\n       [nan, nan, nan, ..., nan, nan, nan],\n       ...,\n       [b'R', nan, nan, ..., nan, nan, nan],\n       [nan, nan, nan, ..., nan, nan, nan],\n       [b'R', nan, nan, ..., nan, nan, nan]], dtype=object)VTPK(TIME, DEPTH)float64...standard_name :sea_surface_wave_period_at_variance_spectral_density_maximumunits :slong_name :Wave period at spectral peak / peak period (Tp)valid_min :1000valid_max :30000comment : uncertainty : accuracy : precision : resolution : cell_methods : type_of_analysis :spectral analysissensor_depth :0.0sensor_mount : sensor_orientation : data_mode :Mancillary_variables :VTPK_QC VTPK_DMarray([[ nan,  nan,  nan, ...,  nan,  nan,  nan],\n       [5.  ,  nan,  nan, ...,  nan,  nan,  nan],\n       [ nan,  nan,  nan, ...,  nan,  nan,  nan],\n       ...,\n       [6.25,  nan,  nan, ...,  nan,  nan,  nan],\n       [ nan,  nan,  nan, ...,  nan,  nan,  nan],\n       [6.67,  nan,  nan, ...,  nan,  nan,  nan]])VTPK_QC(TIME, DEPTH)float32...long_name :Wave period at spectral peak / peak period (Tp) quality flagconventions :Copernicus Marine In Situ reference table 2valid_min :0valid_max :9flag_values :[0 1 2 3 4 5 6 7 8 9]flag_meanings :no_qc_performed good_data probably_good_data bad_data_that_are_potentially_correctable bad_data value_changed value_below_detection nominal_value interpolated_value missing_valuearray([[ 9., nan, nan, ..., nan, nan, nan],\n       [ 1., nan, nan, ..., nan, nan, nan],\n       [ 9., nan, nan, ..., nan, nan, nan],\n       ...,\n       [ 1., nan, nan, ..., nan, nan, nan],\n       [ 9., nan, nan, ..., nan, nan, nan],\n       [ 1., nan, nan, ..., nan, nan, nan]], dtype=float32)VTPK_DM(TIME, DEPTH)object...long_name :Wave period at spectral peak / peak period (Tp) method of data processingconventions :Copernicus Marine In Situ reference table 1flag_values :R, A, Dflag_meanings :real-time adjusted-in-real-time delayed-modearray([[nan, nan, nan, ..., nan, nan, nan],\n       [b'R', nan, nan, ..., nan, nan, nan],\n       [nan, nan, nan, ..., nan, nan, nan],\n       ...,\n       [b'R', nan, nan, ..., nan, nan, nan],\n       [nan, nan, nan, ..., nan, nan, nan],\n       [b'R', nan, nan, ..., nan, nan, nan]], dtype=object)VTZA(TIME, DEPTH)float64...standard_name :sea_surface_wave_mean_periodunits :slong_name :Average zero crossing wave period (Tz)valid_min :2000valid_max :25000comment : uncertainty : accuracy : precision : resolution : cell_methods : type_of_analysis :zero crossingsensor_depth :0.0sensor_mount : sensor_orientation : data_mode :Rancillary_variables :VTZA_QCarray([[4.12,  nan,  nan, ...,  nan,  nan,  nan],\n       [ nan,  nan,  nan, ...,  nan,  nan,  nan],\n       [4.18,  nan,  nan, ...,  nan,  nan,  nan],\n       ...,\n       [ nan,  nan,  nan, ...,  nan,  nan,  nan],\n       [5.44,  nan,  nan, ...,  nan,  nan,  nan],\n       [ nan,  nan,  nan, ...,  nan,  nan,  nan]])VTZA_QC(TIME, DEPTH)float32...long_name :Average zero crossing wave period (Tz) quality flagconventions :Copernicus Marine In Situ reference table 2valid_min :0valid_max :9flag_values :[0 1 2 3 4 5 6 7 8 9]flag_meanings :no_qc_performed good_data probably_good_data bad_data_that_are_potentially_correctable bad_data value_changed value_below_detection nominal_value interpolated_value missing_valuearray([[ 1., nan, nan, ..., nan, nan, nan],\n       [ 9., nan, nan, ..., nan, nan, nan],\n       [ 1., nan, nan, ..., nan, nan, nan],\n       ...,\n       [ 9., nan, nan, ..., nan, nan, nan],\n       [ 1., nan, nan, ..., nan, nan, nan],\n       [ 9., nan, nan, ..., nan, nan, nan]], dtype=float32)VPED(TIME, DEPTH)float64...standard_name :sea_surface_wave_from_direction_at_variance_spectral_density_maximumunits :degreelong_name :Wave principal direction at spectral peakvalid_min :0valid_max :360000comment : uncertainty : accuracy : precision : resolution : cell_methods : type_of_analysis :spectral analysissensor_depth :0.0sensor_mount : sensor_orientation : data_mode :Mancillary_variables :VPED_QC VPED_DMarray([[       nan,        nan,        nan, ...,        nan,        nan,\n               nan],\n       [  2.8     ,        nan,        nan, ...,        nan,        nan,\n               nan],\n       [       nan,        nan,        nan, ...,        nan,        nan,\n               nan],\n       ...,\n       [234.800011,        nan,        nan, ...,        nan,        nan,\n               nan],\n       [       nan,        nan,        nan, ...,        nan,        nan,\n               nan],\n       [244.700012,        nan,        nan, ...,        nan,        nan,\n               nan]])VPED_QC(TIME, DEPTH)float32...long_name :Wave principal direction at spectral peak quality flagconventions :Copernicus Marine In Situ reference table 2valid_min :0valid_max :9flag_values :[0 1 2 3 4 5 6 7 8 9]flag_meanings :no_qc_performed good_data probably_good_data bad_data_that_are_potentially_correctable bad_data value_changed value_below_detection nominal_value interpolated_value missing_valuearray([[ 9., nan, nan, ..., nan, nan, nan],\n       [ 1., nan, nan, ..., nan, nan, nan],\n       [ 9., nan, nan, ..., nan, nan, nan],\n       ...,\n       [ 1., nan, nan, ..., nan, nan, nan],\n       [ 9., nan, nan, ..., nan, nan, nan],\n       [ 1., nan, nan, ..., nan, nan, nan]], dtype=float32)VPED_DM(TIME, DEPTH)object...long_name :Wave principal direction at spectral peak method of data processingconventions :Copernicus Marine In Situ reference table 1flag_values :R, A, Dflag_meanings :real-time adjusted-in-real-time delayed-modearray([[nan, nan, nan, ..., nan, nan, nan],\n       [b'R', nan, nan, ..., nan, nan, nan],\n       [nan, nan, nan, ..., nan, nan, nan],\n       ...,\n       [b'R', nan, nan, ..., nan, nan, nan],\n       [nan, nan, nan, ..., nan, nan, nan],\n       [b'R', nan, nan, ..., nan, nan, nan]], dtype=object)Attributes: (46)platform_code :FINO1platform_name :data_mode :Mtitle :NWS - NRT in situ Observationssummary :Oceanographic data from North West Shelfnaming_authority :Copernicus Marine In Situid :NO_TS_MO_FINO1_202209wmo_platform_code :6201065ices_platform_code :source :mooringsource_platform_category_code :48institution_edmo_code :3356institution :R and D centre Kiel University of Applied Sciencesinstitution_references :www.fh-kiel-gmbh.de/en/site_code :comment :contact :cmems-service@bsh.dearea :North Atlantic Oceangeospatial_lat_min :54.00000geospatial_lat_max :54.00000geospatial_lon_min :6.58333geospatial_lon_max :6.58333last_date_observation :2022-09-30T23:32:00Zlast_latitude_observation :54.00000last_longitude_observation :6.58333geospatial_vertical_min :0.00000geospatial_vertical_max :25.00000time_coverage_start :2022-09-01T00:00:00Ztime_coverage_end :2022-09-30T23:32:00Zcdm_data_type :timeSeriesdata_type :OceanSITES time-series databottom_depth :format_version :1.4Conventions :CF-1.6 Copernicus-InSituTAC-FormatManual-1.42 Copernicus-InSituTAC-SRD-1.5 Copernicus-InSituTAC-ParametersList-3.2.1netcdf_version :netCDF-4 classic modelreferences :http://marine.copernicus.eu http://www.marineinsitu.eudata_assembly_center :BSHupdate_interval :PT1Hcitation :These data were collected and made freely available by the Copernicus project and the programs that contribute to itdistribution_statement :These data follow Copernicus standards; they are public and free of charge. User assumes all risk for use of data. User must display citation in any publication or product using data. User must contact PI prior to any commercial use of data.doi :pi_name :qc_manual :OceanSITES User's Manual v1.2date_update :2022-10-07T05:39:40Zhistory :2022-10-01T18:04:25Z : Creation; 2022-10-07T05:39:40Z, BSH North West Shelf PU: Monthly subset 202209 extracted from history file NO_TS_MO_FINO1.ncwmo_inst_type :\n\n\nCMEMS in-situ data is provided in a standardised format, the OceanSITES time-series data format.\n\n“The OceanSITES programme is the global network of open-ocean sustained time series sites, called ocean reference stations, being implemented by an international partnership of researchers and agencies. OceanSITES provides fixed-point time series of various physical, biogeochemical, ecosystem and atmospheric variables at locations around the globe, from the atmosphere and sea surface to the seafloor. The program’s objective is to build and maintain a multidisciplinary global network for a broad range of research and operational applications including climate, carbon, and ecosystem variability and forecasting and ocean state validation”\n\nFind out which variables we are interested in to extract:\n\npd.DataFrame([{'name': fino[var].name, 'standard_name': fino[var].standard_name, 'units': fino[var].units} for var in fino.data_vars if hasattr(fino[var],\"units\")])\n\n\n\n\n\n  \n    \n      \n      name\n      standard_name\n      units\n    \n  \n  \n    \n      0\n      TEMP\n      sea_water_temperature\n      degrees_C\n    \n    \n      1\n      VHM0\n      sea_surface_wave_significant_height\n      m\n    \n    \n      2\n      VZMX\n      sea_surface_wave_maximum_height\n      m\n    \n    \n      3\n      VTM02\n      sea_surface_wave_mean_period_from_variance_spe...\n      s\n    \n    \n      4\n      VTPK\n      sea_surface_wave_period_at_variance_spectral_d...\n      s\n    \n    \n      5\n      VTZA\n      sea_surface_wave_mean_period\n      s\n    \n    \n      6\n      VPED\n      sea_surface_wave_from_direction_at_variance_sp...\n      degree\n    \n  \n\n\n\n\nThe data have a DEPTH dimension, even though variables are only measured at a single level and doesn’t vary in time although the format allows for it.\nI.e. temperature (TEMP) is available at level 1 (0.5 m)\n\nfino.DEPH.plot.line(x='TIME');\n\n\n\n\n\nfino['TEMP'].plot.line(\"-^\",x='TIME');\n\n\n\n\n\nfino['VHM0'].plot.line(\"-^\",x='TIME');\n\n\n\n\nWave data are only available at the surface.\n\nfino[['VHM0','VTZA','VPED']].isel(DEPTH=0)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.Dataset>\nDimensions:  (TIME: 2879)\nCoordinates:\n  * TIME     (TIME) datetime64[ns] 2022-09-01 ... 2022-09-30T23:31:59.999999744\n    DEPH     (TIME) float32 0.0 0.0 0.0 0.0 0.0 0.0 ... 0.0 0.0 0.0 0.0 0.0 0.0\nData variables:\n    VHM0     (TIME) float64 nan 1.11 nan 1.09 nan ... 2.46 nan 2.41 nan 2.51\n    VTZA     (TIME) float64 4.12 nan 4.18 nan 4.0 nan ... nan 5.2 nan 5.44 nan\n    VPED     (TIME) float64 nan 2.8 nan 353.0 nan ... 192.7 nan 234.8 nan 244.7\nAttributes: (12/46)\n    platform_code:                  FINO1\n    platform_name:                  \n    data_mode:                      M\n    title:                          NWS - NRT in situ Observations\n    summary:                        Oceanographic data from North West Shelf\n    naming_authority:               Copernicus Marine In Situ\n    ...                             ...\n    doi:                            \n    pi_name:                        \n    qc_manual:                      OceanSITES User's Manual v1.2\n    date_update:                    2022-10-07T05:39:40Z\n    history:                        2022-10-01T18:04:25Z : Creation; 2022-10-...\n    wmo_inst_type:                  xarray.DatasetDimensions:TIME: 2879Coordinates: (2)TIME(TIME)datetime64[ns]2022-09-01 ... 2022-09-30T23:31:...long_name :Timestandard_name :timevalid_min :-90000.0valid_max :90000.0uncertainty : comment : axis :Tancillary_variables :TIME_QCarray(['2022-09-01T00:00:00.000000000', '2022-09-01T00:02:00.000000000',\n       '2022-09-01T00:30:00.000000000', ..., '2022-09-30T23:02:00.000000000',\n       '2022-09-30T23:30:00.000000000', '2022-09-30T23:31:59.999999744'],\n      dtype='datetime64[ns]')DEPH(TIME)float320.0 0.0 0.0 0.0 ... 0.0 0.0 0.0 0.0long_name :Depthstandard_name :depthunits :mpositive :downvalid_min :-12000.0valid_max :12000.0uncertainty :comment :axis :Zreference :sea_leveldata_mode :Rancillary_variables :DEPH_QCarray([0., 0., 0., ..., 0., 0., 0.], dtype=float32)Data variables: (3)VHM0(TIME)float64nan 1.11 nan 1.09 ... 2.41 nan 2.51standard_name :sea_surface_wave_significant_heightunits :mlong_name :Spectral significant wave height (Hm0)valid_min :1valid_max :25000comment : uncertainty : accuracy : precision : resolution : cell_methods : type_of_analysis :spectral analysissensor_depth :0.0sensor_mount : sensor_orientation : data_mode :Mancillary_variables :VHM0_QC VHM0_DMarray([ nan, 1.11,  nan, ..., 2.41,  nan, 2.51])VTZA(TIME)float644.12 nan 4.18 nan ... nan 5.44 nanstandard_name :sea_surface_wave_mean_periodunits :slong_name :Average zero crossing wave period (Tz)valid_min :2000valid_max :25000comment : uncertainty : accuracy : precision : resolution : cell_methods : type_of_analysis :zero crossingsensor_depth :0.0sensor_mount : sensor_orientation : data_mode :Rancillary_variables :VTZA_QCarray([4.12,  nan, 4.18, ...,  nan, 5.44,  nan])VPED(TIME)float64nan 2.8 nan ... 234.8 nan 244.7standard_name :sea_surface_wave_from_direction_at_variance_spectral_density_maximumunits :degreelong_name :Wave principal direction at spectral peakvalid_min :0valid_max :360000comment : uncertainty : accuracy : precision : resolution : cell_methods : type_of_analysis :spectral analysissensor_depth :0.0sensor_mount : sensor_orientation : data_mode :Mancillary_variables :VPED_QC VPED_DMarray([       nan,   2.8     ,        nan, ..., 234.800011,        nan,\n       244.700012])Attributes: (46)platform_code :FINO1platform_name :data_mode :Mtitle :NWS - NRT in situ Observationssummary :Oceanographic data from North West Shelfnaming_authority :Copernicus Marine In Situid :NO_TS_MO_FINO1_202209wmo_platform_code :6201065ices_platform_code :source :mooringsource_platform_category_code :48institution_edmo_code :3356institution :R and D centre Kiel University of Applied Sciencesinstitution_references :www.fh-kiel-gmbh.de/en/site_code :comment :contact :cmems-service@bsh.dearea :North Atlantic Oceangeospatial_lat_min :54.00000geospatial_lat_max :54.00000geospatial_lon_min :6.58333geospatial_lon_max :6.58333last_date_observation :2022-09-30T23:32:00Zlast_latitude_observation :54.00000last_longitude_observation :6.58333geospatial_vertical_min :0.00000geospatial_vertical_max :25.00000time_coverage_start :2022-09-01T00:00:00Ztime_coverage_end :2022-09-30T23:32:00Zcdm_data_type :timeSeriesdata_type :OceanSITES time-series databottom_depth :format_version :1.4Conventions :CF-1.6 Copernicus-InSituTAC-FormatManual-1.42 Copernicus-InSituTAC-SRD-1.5 Copernicus-InSituTAC-ParametersList-3.2.1netcdf_version :netCDF-4 classic modelreferences :http://marine.copernicus.eu http://www.marineinsitu.eudata_assembly_center :BSHupdate_interval :PT1Hcitation :These data were collected and made freely available by the Copernicus project and the programs that contribute to itdistribution_statement :These data follow Copernicus standards; they are public and free of charge. User assumes all risk for use of data. User must display citation in any publication or product using data. User must contact PI prior to any commercial use of data.doi :pi_name :qc_manual :OceanSITES User's Manual v1.2date_update :2022-10-07T05:39:40Zhistory :2022-10-01T18:04:25Z : Creation; 2022-10-07T05:39:40Z, BSH North West Shelf PU: Monthly subset 202209 extracted from history file NO_TS_MO_FINO1.ncwmo_inst_type :\n\n\n\ndf = fino[['VHM0','VTZA','VPED']].isel(DEPTH=0).to_dataframe()\n\nThe data are stored on the concurrent timesteps.\n\ndf[['VHM0','VTZA','VPED']].head()\n\n\n\n\n\n  \n    \n      \n      VHM0\n      VTZA\n      VPED\n    \n    \n      TIME\n      \n      \n      \n    \n  \n  \n    \n      2022-09-01 00:00:00\n      NaN\n      4.12\n      NaN\n    \n    \n      2022-09-01 00:02:00\n      1.11\n      NaN\n      2.800000\n    \n    \n      2022-09-01 00:30:00\n      NaN\n      4.18\n      NaN\n    \n    \n      2022-09-01 00:32:00\n      1.09\n      NaN\n      353.000017\n    \n    \n      2022-09-01 01:00:00\n      NaN\n      4.00\n      NaN\n    \n  \n\n\n\n\n\ndf[['VHM0','VTZA']].plot(style='+')\n\n<AxesSubplot: xlabel='TIME'>\n\n\n\n\n\nStore the results in Dfs0 format.\n\npd.Series.to_dfs0?\n\n\nSignature:\npd.Series.to_dfs0(\n    self,\n    filename,\n    itemtype=None,\n    unit=None,\n    items=None,\n    title=None,\n    dtype=None,\n)\nDocstring: <no docstring>\nFile:      ~/mambaforge/lib/python3.10/site-packages/mikeio/dfs0.py\nType:      function\n\n\n\n\n\ndf['VHM0'].dropna().to_dfs0(\"FINO1_VHM0.dfs0\", itemtype=mikeio.EUMType.Significant_wave_height)\n\nRead the file again to check…\n\nds = mikeio.read(\"FINO1_VHM0.dfs0\")\nds\n\n<mikeio.Dataset>\ndims: (time:1439)\ntime: 2022-09-01 00:02:00 - 2022-09-30 23:32:00 (1439 non-equidistant records)\nitems:\n  0:  VHM0 <Significant wave height> (meter)"
  },
  {
    "objectID": "notebooks/Dfsu - Vertical Profile.html",
    "href": "notebooks/Dfsu - Vertical Profile.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "This notebooks demonstrates plotting of vertical profile (transect) dfsu.\n\nimport matplotlib.pyplot as plt\nimport mikeio\n\n\nfilename = \"../tests/testdata/oresund_vertical_slice.dfsu\"\nds = mikeio.read(filename)\nds\n\n<mikeio.Dataset>\ndims: (time:3, element:441)\ntime: 1997-09-15 21:00:00 - 1997-09-16 03:00:00 (3 records)\ngeometry: DfsuVerticalProfileSigmaZ (441 elements, 4 sigma-layers, 5 z-layers)\nitems:\n  0:  Temperature <Temperature> (degree Celsius)\n  1:  Salinity <Salinity> (PSU)\n\n\n\ng = ds.geometry\ng\n\nFlexible Mesh Geometry: DfsuVerticalProfileSigmaZ\nnumber of nodes: 550\nnumber of elements: 441\nnumber of layers: 9 (4 sigma-layers, max 5 z-layers)\nprojection: UTM-33\n\n\n\nimport numpy as np\nec2d = g.element_coordinates[g.top_elements,:2]\nxe, ye = ec2d[:,0], ec2d[:,1]\nnp.argmin((xe - 359615.47172605) ** 2 + (ye - 6.145e+06) ** 2)\n\n11\n\n\n\ng._find_nearest_element_2d([359615,6.145e+06])\n\narray([11])\n\n\n\nds.sel(x=359615, y=6.145e+06, z=-3).plot()\n\n\n\n\nThe geometry can be visualized from above (to be shown on a map) using g.plot() and from the side showing the 2dv transect mesh with g.plot.mesh().\nLet’s show the transect on top of the model domain…\n\ndfs = mikeio.open(\"../tests/testdata/oresundHD_run1.dfsu\")\nmodel_domain = dfs.geometry\n\n\n_, ax = plt.subplots(1,2,figsize=(12,4))\n# left-side plot\nmodel_domain.plot(ax=ax[0], title=\"Transect\")\ng.plot(color=\"r\", ax=ax[0])\n\n# right-side plot\ng.plot.mesh(ax=ax[1], title=\"Transect mesh\");\n\n\n\n\nWe would like to show two points of interest A and B on the map. The geometry object has a method for finding the nearest relative position…\n\nptA = [3.55e+05,  6.145e+06]\nptB = [3.62e+05,  6.166e+06] \ndistA = g.get_nearest_relative_distance(ptA)\ndistB = g.get_nearest_relative_distance(ptB)\ndistA, distB\n\n(5462.327351236415, 27589.50308534942)\n\n\nLet’s now visualize the points on the map and transect\n\n_, ax = plt.subplots(1,2,figsize=(12,4))\nmodel_domain.plot(ax=ax[0], title=\"Transect\")\ng.plot(color=\"r\", ax=ax[0])\nax[0].plot(*ptA, color=\"b\", marker=\"*\", markersize=10)\nax[0].plot(*ptB, color=\"b\", marker=\"*\", markersize=10)\n\ng.plot.mesh(ax=ax[1], title=\"Transect mesh\");\nax[1].axvline(distA, color=\"0.5\")\nax[1].text(distA + 500, -20, 'position A')\nax[1].axvline(distB, color=\"0.5\")\nax[1].text(distB + 500, -20, 'position B');\n\n\n\n\n\nax = ds.Temperature.isel(time=2).plot(figsize=(12,4))\nax.axvline(distA, color=\"0.5\")\nax.text(distA + 500, -20, 'position A')\nax.axvline(distB, color=\"0.5\")\nax.text(distB + 500, -20, 'position B');\n\n\n\n\n\ntime_step = 1\n\nfig, ax = plt.subplots(2,1,figsize=(10,8))\nds.Temperature[time_step].plot(ax=ax[0])\nds.Salinity[time_step].plot(ax=ax[1], title=None);\n\n\n\n\n\n\nA non-straight vertical profile (transect) from a model in geographical coordinates.\n\nfilename = \"../tests/testdata/kalundborg_coarse.mesh\"\nmodel_domain = mikeio.open(filename).geometry\nfilename = \"../tests/testdata/kalundborg_transect.dfsu\"\nds = mikeio.read(filename)\nds\n\n<mikeio.Dataset>\ndims: (time:10, element:1708)\ntime: 2018-02-11 00:00:00 - 2018-02-11 11:15:00 (10 records)\ngeometry: DfsuVerticalProfileSigmaZ (1708 elements, 5 sigma-layers, 20 z-layers)\nitems:\n  0:  U velocity <u velocity component> (meter per sec)\n  1:  V velocity <v velocity component> (meter per sec)\n  2:  Temperature <Temperature> (degree Celsius)\n  3:  Salinity <Salinity> (PSU)\n\n\n\nax = model_domain.plot.outline()\nds.geometry.plot(color=\"cyan\", ax=ax);\n\n\n\n\n\nds.U_velocity.plot(figsize=(12,4));\n\n\n\n\n\n\n\nBoth points and parts of the 2dv domain can selected.\n\nptA = [10.8, 55.6, -3]\nds.geometry.get_nearest_relative_distance(ptA)\n\n28757.285254363647\n\n\nPoints can be extracted:\n\nds_pt = ds.sel(x=ptA[0], y=ptA[1], z=ptA[2])\nds_pt.plot();\n\n\n\n\nAnd vertical columns…\n\nu_col = ds.sel(x=ptA[0], y=ptA[1]).U_velocity\nu_col.plot()\nplt.legend(ds.time);\n\n\n\n\nOr parts of the 2dv transect… here selecting the part with relative distance between 10 and 25 km\n\nrd = ds.geometry.relative_element_distance\nidx = np.where(np.logical_and(10000 < rd, rd < 25000))[0]\ndssub = ds.isel(element=idx)\ndssub\n\n<mikeio.Dataset>\ndims: (time:10, element:579)\ntime: 2018-02-11 00:00:00 - 2018-02-11 11:15:00 (10 records)\ngeometry: DfsuVerticalProfileSigmaZ (579 elements, 4 sigma-layers, 16 z-layers)\nitems:\n  0:  U velocity <u velocity component> (meter per sec)\n  1:  V velocity <v velocity component> (meter per sec)\n  2:  Temperature <Temperature> (degree Celsius)\n  3:  Salinity <Salinity> (PSU)\n\n\n\ndssub.Temperature.plot();\n\n\n\n\nOr specific layers:\n\n# select top 5 layers\nidx = ds.geometry.find_index(layers=range(-6,-1))\ndssub = ds.isel(element=idx)\ndssub\n\n<mikeio.Dataset>\ndims: (time:10, element:971)\ntime: 2018-02-11 00:00:00 - 2018-02-11 11:15:00 (10 records)\ngeometry: DfsuVerticalProfileSigmaZ (971 elements, 3 sigma-layers, 2 z-layers)\nitems:\n  0:  U velocity <u velocity component> (meter per sec)\n  1:  V velocity <v velocity component> (meter per sec)\n  2:  Temperature <Temperature> (degree Celsius)\n  3:  Salinity <Salinity> (PSU)\n\n\n\ndssub.Temperature.plot(figsize=(12,3));"
  },
  {
    "objectID": "notebooks/Dfsu - Connectivity.html",
    "href": "notebooks/Dfsu - Connectivity.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\nimport mikeio\n\n\nds = mikeio.read(\"../tests/testdata/oresundHD_run1.dfsu\")\nds.geometry.plot();\n\n\n\n\nThe info on the connectivity between nodes and elements can be found in the element table\n\net = ds.geometry.element_table\nlen(et)\n\n3612\n\n\n\net[0]\n\narray([718, 229, 143])\n\n\nLet’s find out if any of these nodes are also found in another element, this would imply that these elements are neigbours (adjacent).\n\nfor i, e in enumerate(et):\n    for n in et[0]:\n        if n in e:\n            print(f\"Node: {n} found in element {i}\")\n\nNode: 718 found in element 0\nNode: 229 found in element 0\nNode: 143 found in element 0\nNode: 229 found in element 701\nNode: 718 found in element 743\nNode: 143 found in element 765\nNode: 143 found in element 973\nNode: 718 found in element 974\nNode: 718 found in element 2000\nNode: 229 found in element 2000\nNode: 229 found in element 2080\nNode: 718 found in element 2081\nNode: 718 found in element 2982\nNode: 143 found in element 2982\n\n\n\nne = ds.geometry.n_elements\n\n\nnodetable = {}\nfor el in range(ds.geometry.n_elements):\n    nodes = et[el]\n\n    for node in nodes:\n        if node in nodetable:\n            nodetable[node].append(el)\n        else:\n            nodetable[node] = [el]\n\n\ndef is_neighbour(a, b) -> bool:\n    return len(set(a).intersection(set(b))) == 2\n\n\n# create table with neighbours\nec = {}\nfor el in range(ne):\n    nodes = et[el] # nodes in this element\n\n    for n in nodes:\n        elements = nodetable[n] # elements that has this node \n        for e in elements:\n            if is_neighbour(et[el], et[e]):\n                if el in ec:\n                    if e not in ec[el]:\n                        ec[el].append(e)\n                else:\n                    ec[el] = [e]\n\n\nec[1772]\n\n[1053, 1769, 1773]\n\n\n\n\n\ncoords = ds.geometry.element_coordinates\ne1 = ds.geometry.find_nearest_elements(x=340000,y=6.16e6)\ne1\n\n1722\n\n\n\ne1_n = ec[e1]\ne1_n\n\n[1720, 3125, 1717]\n\n\n\nax = ds.geometry.plot.mesh(figsize=(12,12))\nplt.xlim(330000,360000)\nplt.ylim(6.15e6,6.18e6)\nplt.scatter(coords[e1,0], coords[e1,1], marker='*', s=200, label=\"Selected element\")\nplt.scatter(coords[e1_n,0], coords[e1_n,1], marker='+',c='red', s=200, label=\"Neigbour elements\")\nplt.legend()\n\n<matplotlib.legend.Legend at 0x26a88790520>\n\n\n\n\n\n\n\n\n\nea = ds.geometry.find_nearest_elements(x=343000,y=6168000)\neb = ds.geometry.find_nearest_elements(x=365000,y=6168000)\n\n\nfrom scipy.sparse import lil_matrix, csr_matrix\nfrom scipy.sparse.csgraph import shortest_path\n\nD = lil_matrix((ne, ne))\nfor i in range(ne):\n    row = ec[i]\n    for j in row:\n        d = np.sqrt(\n            (coords[i,0] - coords[j,0]) ** 2 + (coords[i,1] - coords[j,1]) ** 2\n        )\n        D[i, j] = d\nD = csr_matrix(D)\ndist, pred = shortest_path(D, return_predecessors=True)\n\n\ndist[ea,eb]\n\n39874.190780865974\n\n\nThe predessors matrix pred encodes the previous step in the shortest path between any node (in this respect a node in the graph is an element) in the graph. In order to get all steps in the path between two elements we can loop through the steps.\n\npath = [eb] # the destination\nn = eb\nwhile n != ea: # when we reach the start, we are done\n    n = pred[ea,n] # walk backwards\n    path.append(n)\n\npath[0:10]\n\n[3375, 2225, 3376, 2873, 2556, 2872, 2555, 2560, 39, 84]\n\n\nThe path between two elements is here to illustrate how the distance along the shortest path is calculated, you don’t need to use the pred matrix if you are only interested in the distance.\nCalculate the distance through air (ignoring land).\n\neuc_dist = np.sqrt(np.sum((coords[ea,:2] - coords[eb,:2])**2))\n\n\nax = ds.geometry.plot.mesh(figsize=(12,12), title=f\"Distance through air: {euc_dist/1000:.0f} km\\nDistance through water: {dist[ea,eb]/1000:.0f} km\")\nplt.xlim(330000,370000)\nplt.ylim(6.15e6,6.18e6)\nplt.scatter(coords[ea,0], coords[ea,1], marker='*', s=200, label=\"Element A\")\nplt.scatter(coords[eb,0], coords[eb,1], marker='*', s=200, label=\"Element B\")\nplt.scatter(coords[path,0], coords[path,1], marker='.',c='green', s=100, label=\"Shortest path\")\nplt.legend()\n\n<matplotlib.legend.Legend at 0x26a8852ef40>\n\n\n\n\n\n\n\n\n\n# Create sparse connectivity matrix\nC = lil_matrix((ne, ne))\nfor i in range(ne):\n    row = ec[i]\n    for j in row:\n        C[i, j] = 1\n\n\nds\n\n<mikeio.Dataset>\nGeometry: Dfsu2D\nDimensions: (time:5, element:3612)\nTime: 2018-03-07 00:00:00 - 2018-03-11 00:00:00 (5 records)\nItems:\n  0:  Surface elevation <Surface Elevation> (meter)\n  1:  Total water depth <Water Depth> (meter)\n  2:  U velocity <u velocity component> (meter per sec)\n  3:  V velocity <v velocity component> (meter per sec)\n\n\n\ndata = ds.Surface_elevation.values.T\ndata.shape\n\n(3612, 5)\n\n\n\nfrom sklearn.cluster import AgglomerativeClustering\n\nc = AgglomerativeClustering(\n            n_clusters=10, connectivity=C, linkage=\"ward\"\n    ).fit(data)\n\n\nc.labels_\n\narray([8, 9, 7, ..., 0, 0, 0], dtype=int64)\n\n\n\nda = mikeio.DataArray(c.labels_, geometry=ds.geometry, item=\"Cluster #\")\nda\n\n<mikeio.DataArray>\nName: Cluster #\nGeometry: Dfsu2D\nDimensions: (element:3612)\nTime: 2018-01-01 00:00:00 (time-invariant)\n\n\n\nda.plot(figsize=(12,12), cmap='tab10')\n\n<AxesSubplot:title={'center':'2018-01-01 00:00:00'}>"
  },
  {
    "objectID": "notebooks/Dfsu - Export to netcdf.html",
    "href": "notebooks/Dfsu - Export to netcdf.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "Clean up\n\nimport os\nos.remove(\"oresund_sigma_z.nc\")"
  },
  {
    "objectID": "notebooks/Dfsu - Export to shapefile.html",
    "href": "notebooks/Dfsu - Export to shapefile.html",
    "title": "mikeio-examples",
    "section": "",
    "text": "Contour lines\n\n# get coordinates\nec = ds.geometry.element_coordinates\nlon = ec[:,0]\nlat = ec[:,1]\n\n\n# Select item and timestep\nm = ds.Wind_speed[0].to_numpy()\n\n\n# Interpolate to cartesian grid\nfrom  scipy.interpolate import griddata\nnumcols, numrows = 200, 200\nxi = np.linspace(lon.min(), lon.max(), numcols)\nyi = np.linspace(lat.min(), lat.max(), numrows)\nxi, yi = np.meshgrid(xi, yi)\n\ngrid_z = griddata(points=ec[:,0:2],values=m,xi=(xi,yi),method='cubic')\n\n\ncontour_levels=np.arange(4, 14, 0.5)\ncn = plt.contour(xi,yi,grid_z,levels=contour_levels)\n\n\n\n\n\nfrom shapely.geometry import LineString\n\npoly_list = []\n\nfor i in range(len(cn.collections)):\n    p = cn.collections[i].get_paths()[0]\n    v = p.vertices\n    x = v[:,0]\n    y = v[:,1]\n    poly = LineString([(i[0], i[1]) for i in zip(x,y)])\n    if(poly.is_empty):\n        print(f\"{i} is empty\")\n    poly_list.append(poly)\n\n\n# Clip to domain\ndomain = ds.geometry.to_shapely().buffer(0)\npoly_list = [p.intersection(domain) for p in poly_list]\n\n\n# Create GeoDataframe\ndf = pd.DataFrame({'wind_speed':contour_levels})\ngdf = gpd.GeoDataFrame(df,geometry=poly_list)\ngdf.head()\n\n\n\n\n\n  \n    \n      \n      wind_speed\n      geometry\n    \n  \n  \n    \n      0\n      4.0\n      LINESTRING EMPTY\n    \n    \n      1\n      4.5\n      LINESTRING EMPTY\n    \n    \n      2\n      5.0\n      LINESTRING (0.74084 49.95996, 0.79247 49.94723...\n    \n    \n      3\n      5.5\n      LINESTRING (0.74084 50.00444, 0.79247 49.99547...\n    \n    \n      4\n      6.0\n      LINESTRING (0.68920 50.08850, 0.73941 50.06993...\n    \n  \n\n\n\n\n\n# export shapefile\ngdf.to_file(\"wind_speed_contours.shp\")\n\n\n\n\nQGIS\n\n\n\n\nClean up\n\nimport os\n\nfiles = [\"wind_speed\",\"wind_speed_contours\"]\n\nexts = [\"cpg\",\"dbf\",\"shp\",\"shx\"]\n\nfor file in files:\n    for ext in exts:\n        filename = f\"{file}.{ext}\"\n        if os.path.exists(filename): os.remove(filename)"
  }
]